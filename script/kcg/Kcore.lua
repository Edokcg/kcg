CARDDATA_PICCODE		=1
EFFECT_SET_ENTITY = 2032
EVENT_ENTITY_RESET = 2033
OPCODE_ISLEVEL      =0x4000009100000000
OPCODE_ISLEVELLARGER      =0x4000009200000000
OPCODE_ISLEVELSMALLER      =0x4000009300000000

aux.AIchk = {0,0}
aux.AISystem = {0,0}
--zdiy--
aux.IsKCGScript = true
--zdiy--


Auxiliary.sinlist={
    [79856792] = 88,
    [1546123] = 89,
    [89631139] = 90,
    [CARD_STARDUST_DRAGON] = 91,
    [74677422] = 92,
    [10000010] = 129,
    [10000020] = 131,
    [57793869] = 132,
    [6007213] = 133
}
Auxiliary.burstlist={
    [6021033] = 1764972,
    [31924889] = 14553285,
    [95526884] = 37169670,
    [23693634] = 38898779,
    [97836203] = 47027714,
    [CARD_STARDUST_DRAGON] = 61257789,
    [70902743] = 511002518,
    --neet
    [28240337] = 1124,
    [51447164] = 1355,
    [1534] = 1535,
}
Auxiliary.nolist = {
    [0] = 65305468,
    [1] = 15232745,
    [2] = 42230449,
    [3] = 78625448,
    [4] = 4019153,
    [5] = 90126061,
    [6] = 9161357,
    [7] = 82308875,
    [8] = 47387961,
    [9] = 1992816,
    [10] = 11411223,
    [11] = 80117527,
    [12] = 19333131,
    [13] = 69058960,
    [14] = 21313376,
    [15] = 88120966,
    [16] = 54719828,
    [17] = 69610924,
    [18] = 23649496,
    [19] = 55067058,
    [20] = 47805931,
    [21] = 57707471,
    [22] = 73445448,
    [23] = 66547759,
    [24] = 93713837,
    [25] = 64554883,
    [26] = 39622156,
    [27] = 8387138,
    [28] = 53701457,
    [29] = 54191698,
    [30] = 81330115,
    [31] = 95442074,
    [32] = 65676461,
    [33] = 39139935,
    [34] = 32003338,
    [35] = 90162951,
    [36] = 50260683,
    [37] = 37279508,
    [38] = 63767246,
    [39] = 84013237,
    [40] = 75433814,
    [41] = 90590303,
    [42] = 10389142,
    [43] = 56051086,
    [44] = 80764541,
    [45] = 29208536,
    [46] = 2978414,
    [47] = 31320433,
    [48] = 1426714,
    [49] = 16259549,
    [50] = 51735257,
    [51] = 56292140,
    [52] = 7194917,
    [53] = 23998625,
    [54] = 54366836,
    [55] = 46871387,
    [56] = 55935416,
    [57] = 53244294,
    [58] = 93108839,
    [59] = 82697249,
    [60] = 66011101,
    [61] = 29669359,
    [62] = 31801517,
    [63] = 89642993,
    [64] = 39972129,
    [65] = 3790062,
    [66] = 76067258,
    [67] = 35772782,
    [68] = 23085002,
    [69] = 2407234,
    [70] = 80796456,
    [71] = 59479050,
    [72] = 75253697,
    [73] = 36076683,
    [74] = 16037007,
    [75] = 71166481,
    [76] = 92015800,
    [77] = 62541668,
    [78] = 29085954,
    [79] = 71921856,
    [80] = 20563387,
    [81] = 49032236,
    [82] = 16398062,
    [83] = 16398063,
    [84] = 16398072,
    [85] = 42421606,
    [86] = 63504681,
    [87] = 16398070,
    [88] = 6165656,
    [89] = 16398054,
    [90] = 8165596,
    [91] = 84417082,
    [92] = 47017574,
    [93] = 16398076,
    [94] = 62070231,
    [95] = 16398086,
    [96] = 77205367,
    [97] = 28400508,
    [98] = 16398073,
    [99] = 51543904,
    [100] = 57314798,
    [101] = 12744567,
    [102] = 67173574,
    [103] = 20785975,
    [104] = 49456901,
    [105] = 85121942,
    [106] = 55888045,
    [107] = 68396121
}
Auxiliary.nolist_anime = {
    [0] = 209,
    [1] = 13701,
    [2] = 13702,
    [3] = 13703,
    [4] = 13704,
    [5] = 90126061,
    [6] = 511002090,
    [7] = 511010007,
    [8] = 511001374,
    [9] = 511010009,
    [10] = 11411223,
    [11] = 80117527,
    [12] = 511010012,
    [13] = 511015132,
    [14] = 511000184,
    [15] = 511001999,
    [16] = 513000018,
    [17] = 511002077,
    [18] = 23649496,
    [19] = 511001779,
    [20] = 47805931,
    [21] = 511010021,
    [22] = 73445448,
    [23] = 511000183,
    [24] = 93713837,
    [25] = 511010025,
    [26] = 39622156,
    [27] = 8387138,
    [28] = 511000512,
    [29] = 54191698,
    [30] = 511010030,
    [31] = 511015133,
    [32] = 511010032,
    [33] = 511002091,
    [34] = 32003339,
    [35] = 511010035,
    [36] = 50260683,
    [37] = 511001273,
    [38] = 511001275,
    [39] = 60,
    [40] = 511002830,
    [41] = 90590303,
    [42] = 511002054,
    [43] = 511001776,
    [44] = 511001997,
    [45] = 29208536,
    [46] = 511001998,
    [47] = 31320433,
    [48] = 511015118,
    [49] = 16259549,
    [50] = 511002060,
    [51] = 56292140,
    [52] = 511002058,
    [53] = 511010053,
    [54] = 511002727,
    [55] = 46871387,
    [56] = 511010056,
    [57] = 53244294,
    [58] = 511002873,
    [59] = 82697249,
    [60] = 66011101,
    [61] = 511002088,
    [62] = 150,
    [63] = 89642993,
    [64] = 511010064,
    [65] = 511010065,
    [66] = 76067258,
    [67] = 35772782,
    [68] = 23085002,
    [69] = 237,
    [70] = 80796456,
    [71] = 59479050,
    [72] = 511015129,
    [73] = 511002092,
    [74] = 16037007,
    [75] = 71166481,
    [76] = 92015800,
    [77] = 357,
    [78] = 29085954,
    [79] = 71921856,
    [80] = 513000062,
    [81] = 49032236,
    [82] = 511002064,
    [83] = 511010083,
    [84] = 26556950,
    [85] = 42421606,
    [86] = 63504681,
    [87] = 89516305,
    [88] = 151,
    [89] = 95474755,
    [90] = 8165596,
    [91] = 511002059,
    [92] = 240,
    [93] = 389,
    [94] = 62070231,
    [95] = 511000515,
    [96] = 55727845,
    [97] = 28400508,
    [98] = 55470553,
    [99] = 210,
    [100] = 13714,
    [101] = 97,
    [102] = 254,
    [103] = 259,
    [104] = 256,
    [105] = 252,
    [106] = 248,
    [107] = 99,
    [1000] = 586
}
Auxiliary.notoclist = {
    [1] = 79747096,
    [2] = 583,
    [3] = 584,
    [4] = 585,
    [5] = 69757518,
    [6] = 6387204,
    [9] = 32559361,
    [15] = 33776843,
    [20] = 1876,
    [21] = 1878,
    [23] = 1756,
    [24] = 20200920,
    [30] = 20200916,
    [32] = 7628844,
    [37] = 1755,
    [39] = 66970002,
    [40] = 69170557,
    [43] = 32446630,
    [48] = 20210702,
    [49] = 1769,
    [52] = 20210621,
    [53] = 23998625,
    [55] = 20190118,
    [60] = 20191029,
    [62] = 48348921,
    [65] = 49195710,
    [69] = 11522979,
    [70] = 20200329,
    [73] = 96864105,
    [75] = 20210620,
    [76] = 20191031,
    [79] = 100432035,
    [80] = 20563387,
    [82] = 1754,
    [88] = 6165656,
    [89] = 20191027,
    [91] = 1827,
    [92] = 47017574,
    [96] = 77205367,
    [98] = 20191028,
    [100] = 57314798,
    [101] = 12744567,
    [102] = 67173574,
    [103] = 20785975,
    [104] = 49456901,
    [105] = 85121942,
    [106] = 55888045,
    [107] = 68396121,
    [1000] = 89477759
}
Auxiliary.cxlist = {
    [77631175] = 13030280,
    [51960178] = 23454876,
    [14152862] = 41147577,
    [15914410] = 511600284,
    [3814632] = 49202331,
    [40424929] = 76419637,
    [30741334] = 88754763,
    [787] = 13718,
    [602] = 603,
    [34876719] = 166,
    [31563350] = 511002000,
    [68836428] = 155,
    [76290637] = 3685372
}

--GOD common effects
function aux.god(c,class,id,dmgod)
    --class: 1=anime, 2=manga
    --dmgod: spsummon cost/effect
    --通常召唤、特殊召唤、反转召唤不会被无效化
    local e8=Effect.CreateEffect(c)
    e8:SetType(EFFECT_TYPE_SINGLE)
    e8:SetCode(EFFECT_CANNOT_DISABLE_SUMMON)
    e8:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
    e8:SetCondition(aux.godanime1)
    c:RegisterEffect(e8)
    local e9=e8:Clone()
    e9:SetCode(EFFECT_CANNOT_DISABLE_SPSUMMON)
    c:RegisterEffect(e9)
    local e10=e9:Clone()
    e10:SetCode(EFFECT_CANNOT_DISABLE_FLIP_SUMMON)
    c:RegisterEffect(e10)

    if id~=83 and id~=708 and id~=824 and id~=825 then
        --not Ra
        --cannot chain when summon
        local e11=Effect.CreateEffect(c)
        e11:SetProperty(EFFECT_FLAG_UNCOPYABLE)
        e11:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
        e11:SetCode(EVENT_SUMMON_SUCCESS)
        --choose anime/manga
        if id==818 then
            e11:SetOperation(aux.osumsuc)
        elseif id==821 then
            e11:SetOperation(aux.ssumsuc)
        elseif id==805 then
            e11:SetOperation(aux.lsumsuc)
        else
            e11:SetCondition(aux.godanime1)
            e11:SetOperation(aux.sumsuc0)
        end
        c:RegisterEffect(e11)
        local e12=e11:Clone()
        e12:SetCode(EVENT_SPSUMMON_SUCCESS)
        c:RegisterEffect(e12)
        local e13=e11:Clone()
        e13:SetCode(EVENT_FLIP_SUMMON_SUCCESS)
        c:RegisterEffect(e13)
    else
        --Ra
        local form=0
        if id==83 then form=3 end
        if id==708 then form=1 end
        if id==824 then form=2 end
        if id==825 then form=0 end
        local e11=Effect.CreateEffect(c)
        e11:SetProperty(EFFECT_FLAG_UNCOPYABLE)
        e11:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
        e11:SetCode(EVENT_SUMMON_SUCCESS)
        e11:SetLabel(form)
        e11:SetOperation(aux.rsumsuc)
        c:RegisterEffect(e11)
        local e12=e11:Clone()
        e12:SetCode(EVENT_SPSUMMON_SUCCESS)
        --no mound of bound, choose which mode
        e12:SetCondition(aux.rsumsuccon)
        c:RegisterEffect(e12)
        local e13=e11:Clone()
        e13:SetCode(EVENT_FLIP_SUMMON_SUCCESS)
        c:RegisterEffect(e13)

        --mound of bound, no choose which mode
        local e14=Effect.CreateEffect(c)
        e14:SetProperty(EFFECT_FLAG_UNCOPYABLE)
        e14:SetType(EFFECT_TYPE_SINGLE + EFFECT_TYPE_CONTINUOUS)
        e14:SetCode(EVENT_SPSUMMON_SUCCESS)
        e14:SetLabel(form)
        e14:SetCondition(aux.rsumsuccon2)
        e14:SetOperation(aux.rsumsuc)
        c:RegisterEffect(e14)
    end

    --one turn immune
    local e16 = Effect.CreateEffect(c)
    e16:SetType(EFFECT_TYPE_SINGLE)
    e16:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e16:SetRange(LOCATION_MZONE)
    e16:SetCode(EFFECT_IMMUNE_EFFECT)
    e16:SetCondition(aux.godlv0)
    e16:SetLabel(class)
    e16:SetValue(aux.efilterr)
    c:RegisterEffect(e16)
    local te2=Effect.CreateEffect(c)
	te2:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
	te2:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_DAMAGE_STEP+EFFECT_FLAG_DAMAGE_CAL)
	te2:SetCode(EVENT_CHAINING)
	te2:SetRange(LOCATION_MZONE)
    te2:SetCondition(aux.godlv0)
    te2:SetLabel(class)
	te2:SetOperation(aux.chop)
	c:RegisterEffect(te2)
    --reset one turn immune
    local te = Effect.CreateEffect(c)
    te:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
	te:SetProperty(EFFECT_FLAG_CANNOT_DISABLE)
    te:SetRange(LOCATION_MZONE)
    te:SetCountLimit(1)
    te:SetCode(EVENT_TURN_END)
    te:SetCondition(aux.godlv0)
    te:SetOperation(aux.reop2)
    c:RegisterEffect(te)
    
    local e15 = Effect.CreateEffect(c)
    if dmgod==1 then
        local e3=Effect.CreateEffect(c) 
        e3:SetProperty(EFFECT_FLAG_DAMAGE_CAL+EFFECT_FLAG_DAMAGE_STEP+EFFECT_FLAG_DELAY+EFFECT_FLAG_CANNOT_DISABLE)
        e3:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
        e3:SetCode(EVENT_OVERLAY)
        e3:SetOperation(aux.efop)
        c:RegisterEffect(e3)
        -- 特召回合结束送去特召前区域
        e15:SetType(EFFECT_TYPE_FIELD + EFFECT_TYPE_CONTINUOUS)
        e15:SetRange(LOCATION_MZONE)
        e15:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE)
        e15:SetCountLimit(1)
        e15:SetCode(EVENT_PHASE + PHASE_END)
        e15:SetCondition(aux.tgcon)
        e15:SetOperation(aux.tgop)
        e15:SetValue(0)
        c:RegisterEffect(e15)

        -- 特召后成为攻击目标
        local e26 = Effect.CreateEffect(c)
        e26:SetType(EFFECT_TYPE_FIELD + EFFECT_TYPE_TRIGGER_O)
        e26:SetRange(LOCATION_MZONE)
        e26:SetCode(EVENT_ATTACK_ANNOUNCE)
        e26:SetCondition(aux.atcon2)
        e26:SetOperation(aux.atop)
        c:RegisterEffect(e26)
        -- destroy replace
        local e27 = Effect.CreateEffect(c)
        e27:SetType(EFFECT_TYPE_CONTINUOUS + EFFECT_TYPE_FIELD)
        e27:SetCode(EFFECT_DESTROY_REPLACE)
        e27:SetRange(LOCATION_MZONE)
        e27:SetCondition(aux.atcon)
        e27:SetTarget(aux.reptg)
        e27:SetValue(aux.repval)
        e27:SetOperation(aux.repop)
        c:RegisterEffect(e27)
        
        --not Ra
        if id~=83 and id~=708 and id~=824 and id~=825 then
            local e19 = Effect.CreateEffect(c)
            e19:SetType(EFFECT_TYPE_SINGLE)
            e19:SetCode(EFFECT_CANNOT_ATTACK)
            e19:SetCondition(aux.atcon)
            c:RegisterEffect(e19)
        end
    end

    local e20 = Effect.CreateEffect(c)
    e20:SetType(EFFECT_TYPE_SINGLE)
    e20:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e20:SetRange(LOCATION_MZONE)
    e20:SetCode(EFFECT_CANNOT_CHANGE_CONTROL)
    e20:SetCondition(aux.retcon3)
    e20:SetValue(1)
    c:RegisterEffect(e20)

    -- 不会被卡的效果破坏、除外、返回手牌和卡组、送去墓地、无效化、改变控制权、变成里侧表示、作为特殊召唤素材
    -- local e100 = Effect.CreateEffect(c)
    -- e100:SetType(EFFECT_TYPE_SINGLE)
    -- e100:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    -- e100:SetRange(LOCATION_MZONE)
    -- e100:SetCode(EFFECT_INDESTRUCTABLE_EFFECT)
    -- e100:SetCondition(aux.godanime)
    -- e100:SetLabelObject(e15)
    -- e100:SetLabel(class)
    -- e100:SetValue(1)
    -- --e100:SetValue(function(ae,are,arp) return ae:GetOwnerPlayer()~=arp end)
    -- c:RegisterEffect(e100)
    local e101=Effect.CreateEffect(c)
    e101:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e101:SetRange(LOCATION_MZONE)
    e101:SetCode(EFFECT_SEND_REPLACE)
    e101:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
    e101:SetTarget(aux.oreptg1)
    e101:SetLabel(class)
    c:RegisterEffect(e101)
    -- local e101 = e100:Clone()
    -- e101:SetCondition(aux.econ)
    -- e101:SetCode(EFFECT_CANNOT_REMOVE)
    -- c:RegisterEffect(e101)
    -- local e102 = e101:Clone()
    -- e102:SetCode(EFFECT_CANNOT_TO_HAND)
    -- c:RegisterEffect(e102)
    -- local e103 = e101:Clone()
    -- e103:SetCode(EFFECT_CANNOT_TO_DECK)
    -- e103:SetCondition(aux.econ2)
    -- c:RegisterEffect(e103)
    -- local e104 = e101:Clone()
    -- e104:SetCode(EFFECT_CANNOT_TO_GRAVE)
    -- c:RegisterEffect(e104)
    local e105 = Effect.CreateEffect(c)
    e105:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e105:SetRange(LOCATION_MZONE)
    e105:SetCode(EFFECT_CANNOT_DISABLE)
    e105:SetLabel(class)
    e105:SetCondition(aux.godanime)
    c:RegisterEffect(e105)
    local e107 = e105:Clone()
    e107:SetCode(EFFECT_CANNOT_TURN_SET)
    c:RegisterEffect(e107)
    local e108 = Effect.CreateEffect(c)
    e108:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e108:SetRange(LOCATION_MZONE)
	e108:SetCode(EFFECT_CANNOT_BE_MATERIAL)
    e108:SetLabel(class)
    e108:SetCondition(aux.godanime)
	e108:SetValue(aux.cannotmatfilter(SUMMON_TYPE_FUSION,SUMMON_TYPE_SYNCHRO,SUMMON_TYPE_XYZ,SUMMON_TYPE_LINK))
    c:RegisterEffect(e108)

    local e112 = Effect.CreateEffect(c)
    e112:SetType(EFFECT_TYPE_FIELD)
    e112:SetProperty(EFFECT_FLAG_PLAYER_TARGET)
    e112:SetCode(EFFECT_CANNOT_RELEASE)
    e112:SetRange(LOCATION_MZONE)
    e112:SetTargetRange(0, 1)
    e112:SetTarget(aux.rellimit)
    e112:SetLabel(class)
    e112:SetCondition(aux.godmanga)
    c:RegisterEffect(e112)

    local e17 = Effect.CreateEffect(c)
    e17:SetType(EFFECT_TYPE_SINGLE)
    e17:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e17:SetRange(LOCATION_MZONE)
    e17:SetCode(EFFECT_GOD_IMMUNE)
    e17:SetLabel(class)
    e17:SetCondition(aux.godmanga)
    c:RegisterEffect(e17)

    local e18 = Effect.CreateEffect(c)
    e18:SetType(EFFECT_TYPE_SINGLE)
    e18:SetCode(EFFECT_INDESTRUCTABLE_BATTLE)
    e18:SetLabel(class)
    e18:SetCondition(aux.godmanga)
    e18:SetValue(function(e, tc)
        if not tc then
            return false
        end
        local c = e:GetOwner()
        local tc_godlv = tc:GetGodLevel()
        local c_godlv = c:GetGodLevel()
        if tc==c then
            return false
        else
            local uatk=0
            local atk=tc:GetAttack()
            if tc:IsDefensePos() then atk=tc:GetDefense() end
            local tatk=tc:GetBaseAttack()
            if tc:IsDefensePos() then tatk=tc:GetBaseDefense() end
            local batk=tc:GetBaseAttack()
            if tc:IsDefensePos() then batk=tc:GetBaseDefense() end
            local tae={}
            local ae={tc:IsHasEffect(EFFECT_UPDATE_ATTACK)}
            if tc:IsDefensePos() then ae={tc:IsHasEffect(EFFECT_UPDATE_DEFENSE)} end
            local ae2={tc:IsHasEffect(EFFECT_INF_ATTACK)}
            if tc:IsDefensePos() then ae2={tc:IsHasEffect(EFFECT_INF_DEFENSE)} end
            local ae3={tc:IsHasEffect(EFFECT_OVERINFINITE_ATTACK)}
            if tc:IsDefensePos() then ae3={tc:IsHasEffect(EFFECT_OVERINFINITE_DEFENSE)} end
            local ae4={tc:IsHasEffect(EFFECT_SET_ATTACK_FINAL)}
            if tc:IsDefensePos() then ae4={tc:IsHasEffect(EFFECT_SET_DEFENSE_FINAL)} end
            local ae5={tc:IsHasEffect(EFFECT_SET_ATTACK)}
            if tc:IsDefensePos() then ae5={tc:IsHasEffect(EFFECT_SET_DEFENSE)} end
            for _, te in ipairs(ae) do
                local tec = te:GetOwner()
                local tec_godlv = tec:GetGodLevel()
                if not (tec:IsType(TYPE_TRAP)
                or (tec:IsType(TYPE_MONSTER) 
                  and ((tec_godlv==c_godlv and ((not tec:IsLevelAbove(c:GetLevel()) and tec:HasLevel()) or (not tec:IsRankAbove(c:GetLevel()) and tec:HasRank()) or (not tec:IsLinkAbove(c:GetLevel()) and tec:HasLink())))
                    or c_godlv>tec_godlv))) then
                    local valf = te:GetValue()
                    if type(valf)=="function" then
                        uatk = uatk + valf(te)
                    else
                        uatk = uatk + valf
                    end
                end
            end
            batk = batk + uatk
            for _, te in ipairs(ae5) do
                local tec = te:GetOwner()
                local tec_godlv = tec:GetGodLevel()
                if not (tec:IsType(TYPE_TRAP)
                or (tec:IsType(TYPE_MONSTER) 
                  and ((tec_godlv==c_godlv and ((not tec:IsLevelAbove(c:GetLevel()) and tec:HasLevel()) or (not tec:IsRankAbove(c:GetLevel()) and tec:HasRank()) or (not tec:IsLinkAbove(c:GetLevel()) and tec:HasLink())))
                    or c_godlv>tec_godlv))) then
                    local valf = te:GetValue()
                    if type(valf)=="function" then
                        if valf(te) + uatk > batk then
                            batk = valf(te) + uatk
                        end
                    else
                        if valf + uatk > batk then
                            batk = valf + uatk
                        end
                    end
                end
            end
            for _, te in ipairs(ae4) do
                local tec = te:GetOwner()
                local tec_godlv = tec:GetGodLevel()
                if not (tec:IsType(TYPE_TRAP)
                or (tec:IsType(TYPE_MONSTER) 
                  and ((tec_godlv==c_godlv and ((not tec:IsLevelAbove(c:GetLevel()) and tec:HasLevel()) or (not tec:IsRankAbove(c:GetLevel()) and tec:HasRank()) or (not tec:IsLinkAbove(c:GetLevel()) and tec:HasLink())))
                    or c_godlv>tec_godlv))) then
                    local valf = te:GetValue()
                    if type(valf)=="function" then
                        if valf(te) + uatk > batk then
                            batk = valf(te) + uatk
                        end
                    else
                        if valf + uatk > batk then
                            batk = valf + uatk
                        end
                    end
                end
            end
            for _, te in ipairs(ae2) do
                local tec = te:GetOwner()
                local tec_godlv = tec:GetGodLevel()
                if not (tec:IsType(TYPE_TRAP)
                or (tec:IsType(TYPE_MONSTER) 
                  and ((tec_godlv==c_godlv and ((not tec:IsLevelAbove(c:GetLevel()) and tec:HasLevel()) or (not tec:IsRankAbove(c:GetLevel()) and tec:HasRank()) or (not tec:IsLinkAbove(c:GetLevel()) and tec:HasLink())))
                    or c_godlv>tec_godlv))) then
                    batk = 8888888
                end
            end
            for _, te in ipairs(ae3) do
                local tec = te:GetOwner()
                local tec_godlv = tec:GetGodLevel()
                if not (tec:IsType(TYPE_TRAP)
                or (tec:IsType(TYPE_MONSTER) 
                  and ((tec_godlv==c_godlv and ((not tec:IsLevelAbove(c:GetLevel()) and tec:HasLevel()) or (not tec:IsRankAbove(c:GetLevel()) and tec:HasRank()) or (not tec:IsLinkAbove(c:GetLevel()) and tec:HasLink())))
                    or c_godlv>tec_godlv))) then
                    batk = 9999999
                end
            end
            return batk<c:GetAttack() and atk~=tatk
        end
    end)
    c:RegisterEffect(e18)
    local e19 = e18:Clone()
    e19:SetCode(EFFECT_AVOID_BATTLE_DAMAGE)
    c:RegisterEffect(e19)
end

--Sky Dragon
function aux.skydragon(c,form,id)
    --form=0:anime/manga, 1:anime, 2:manga, 3:real god
    local e1 = aux.AddNormalSummonProcedure(c, true, false, 3, 3)
    local e2 = aux.AddNormalSetProcedure(c, true, false, 3, 3)

    local e3 = Effect.CreateEffect(c)
    e3:SetType(EFFECT_TYPE_SINGLE)
    e3:SetProperty(EFFECT_FLAG_CANNOT_DISABLE + EFFECT_FLAG_UNCOPYABLE)
    e3:SetCode(EFFECT_ADD_RACE)
    if form<3 then
        e3:SetValue(RACE_DRAGON)
    else
        e3:SetValue(RACE_DRAGON+RACE_CREATORGOD)
    end
    c:RegisterEffect(e3)

    if form>0 then
        -- 召唤后攻守数值
        local e0=Effect.CreateEffect(c)
        e0:SetType(EFFECT_TYPE_SINGLE)
        e0:SetProperty(EFFECT_FLAG_UNCOPYABLE+EFFECT_FLAG_CANNOT_DISABLE)
        e0:SetCode(id)
        c:RegisterEffect(e0)
        local e4=Effect.CreateEffect(c)
        e4:SetType(EFFECT_TYPE_SINGLE)
        e4:SetProperty(EFFECT_FLAG_SINGLE_RANGE+EFFECT_FLAG_UNCOPYABLE)
        e4:SetRange(LOCATION_MZONE)
        e4:SetCode(EFFECT_SET_BASE_ATTACK)
        e4:SetCondition(function(e) return e:GetHandler():IsHasEffect(id) end)
        e4:SetValue(aux.adval)
        c:RegisterEffect(e4)
        local e5=e4:Clone()
        e5:SetCode(EFFECT_SET_BASE_DEFENSE)
        c:RegisterEffect(e5)
        
        -- 下降对手怪兽攻击、破坏
        local e6 = Effect.CreateEffect(c)
        e6:SetProperty(EFFECT_FLAG_CARD_TARGET + EFFECT_FLAG_DAMAGE_CAL + EFFECT_FLAG_DAMAGE_STEP)
        e6:SetDescription(aux.Stringid(10000020, 1))
        e6:SetCategory(CATEGORY_ATKCHANGE + CATEGORY_DEFCHANGE)
        e6:SetType(EFFECT_TYPE_FIELD + EFFECT_TYPE_TRIGGER_F)
        e6:SetRange(LOCATION_MZONE)
        --e6:SetCountLimit(10)
        e6:SetCode(EVENT_SUMMON_SUCCESS)
        e6:SetTarget(aux.satktg)
        e6:SetOperation(aux.satkop)
        c:RegisterEffect(e6)
        local e7 = e6:Clone()
        e7:SetCode(EVENT_SPSUMMON_SUCCESS)
        c:RegisterEffect(e7)
        local e8 = e7:Clone()
        e8:SetCode(EVENT_FLIP_SUMMON_SUCCESS)
        c:RegisterEffect(e8)
    end
end

--Obelisk
function aux.obelisk(c,form)
    --form=0:, 1:anime, 2:manga, 3:real god
    local e1 = aux.AddNormalSummonProcedure(c, true, false, 3, 3)
    local e2 = aux.AddNormalSetProcedure(c, true, false, 3, 3)
    
    if form>0 then
        if form==3 then
            local e3 = Effect.CreateEffect(c)
            e3:SetType(EFFECT_TYPE_SINGLE)
            e3:SetProperty(EFFECT_FLAG_CANNOT_DISABLE + EFFECT_FLAG_UNCOPYABLE)
            e3:SetCode(EFFECT_ADD_RACE)
            e3:SetValue(RACE_CREATORGOD)
            c:RegisterEffect(e3)
        end

        -- 解放2只怪破坏对方场上怪兽
        local e3 = Effect.CreateEffect(c)
        e3:SetDescription(aux.Stringid(10000000, 1))
        e3:SetCategory(CATEGORY_DESTROY)
        e3:SetType(EFFECT_TYPE_IGNITION)
        e3:SetRange(LOCATION_MZONE)
        e3:SetCountLimit(1)
        e3:SetCost(aux.odescost)
        e3:SetTarget(aux.odestg)
        e3:SetOperation(aux.odesop)
        c:RegisterEffect(e3)
    
        -- 解放2只怪提升攻击为无限
        local e4 = Effect.CreateEffect(c)
        e4:SetDescription(aux.Stringid(10000010, 0))
        e4:SetCategory(CATEGORY_ATKCHANGE)
        e4:SetType(EFFECT_TYPE_QUICK_O)
        e4:SetCode(EVENT_FREE_CHAIN)
        e4:SetHintTiming(TIMING_BATTLE_PHASE)
        e4:SetRange(LOCATION_MZONE)
        e4:SetCountLimit(1)
        e4:SetCondition(aux.oatkcon)
        e4:SetCost(aux.oatkcost)
        e4:SetOperation(aux.oatkop)
        c:RegisterEffect(e4)
    end
end

--Ra
function aux.phoenix(c,form,id)
    --form=0:choose, 1:anime, 2:manga, 3:real god
	local e1=aux.AddNormalSummonProcedure(c,true,false,3,3,SUMMON_TYPE_TRIBUTE,aux.Stringid(10000080,0))
	local e2=aux.AddNormalSetProcedure(c,true,false,3,3,SUMMON_TYPE_TRIBUTE,aux.Stringid(10000080,0))
	local e3=Effect.CreateEffect(c)
	e3:SetDescription(aux.Stringid(10000080,1))
	e3:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE+EFFECT_FLAG_SPSUM_PARAM)
	e3:SetType(EFFECT_TYPE_SINGLE)
	e3:SetCode(EFFECT_LIMIT_SUMMON_PROC)
	e3:SetTargetRange(POS_FACEUP_ATTACK,1)
	e3:SetCondition(aux.ttcon2)
	e3:SetTarget(aux.tttg2)
	e3:SetOperation(aux.ttop2)
	e3:SetValue(SUMMON_TYPE_TRIBUTE)
	c:RegisterEffect(e3)

	--通常召唤后攻守数值
	local e4=Effect.CreateEffect(c)
	e4:SetProperty(EFFECT_FLAG_CANNOT_DISABLE)
	e4:SetType(EFFECT_TYPE_SINGLE)
	e4:SetCode(EFFECT_MATERIAL_CHECK)
	e4:SetValue(aux.valcheck)
	c:RegisterEffect(e4)
	local e5=Effect.CreateEffect(c)
	e5:SetProperty(EFFECT_FLAG_CANNOT_DISABLE)
	e5:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
	e5:SetCode(EVENT_SUMMON_SUCCESS)
	e5:SetLabelObject(e4)
	e5:SetOperation(aux.atkop)
	c:RegisterEffect(e5)

	local e6=Effect.CreateEffect(c)
	e6:SetType(EFFECT_TYPE_SINGLE)
	e6:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
	e6:SetCode(EFFECT_ADD_RACE)
	e6:SetValue(RACE_DRAGON+RACE_CREATORGOD)
	c:RegisterEffect(e6)

    -- control return
    local e7=Effect.CreateEffect(c)
    e7:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
    e7:SetCode(EVENT_PHASE+PHASE_END)
    e7:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE+EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
    e7:SetRange(LOCATION_MZONE)
    e7:SetCountLimit(1)
    e7:SetLabel(id)
    if form==0 then
        e7:SetOperation(aux.retop0)
    else
        e7:SetOperation(aux.retop)
    end
    c:RegisterEffect(e7)

    --egg attack limit
    local e21 = Effect.CreateEffect(c)
    e21:SetType(EFFECT_TYPE_SINGLE)
    e21:SetCode(EFFECT_CANNOT_ATTACK)
    e21:SetCondition(aux.retcon2)
    c:RegisterEffect(e21)
    local e22 = e21:Clone()
    e22:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e22:SetRange(LOCATION_MZONE)
    e22:SetCode(EFFECT_CANNOT_TRIGGER)
    c:RegisterEffect(e22)
    local e23 = e21:Clone()
    e23:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e23:SetCode(EFFECT_CANNOT_CHANGE_POSITION)
    e23:SetRange(LOCATION_MZONE)
    c:RegisterEffect(e23)

    --egg cannot be target
    local e24 = Effect.CreateEffect(c)
    e24:SetType(EFFECT_TYPE_SINGLE)
    e24:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e24:SetCode(EFFECT_IGNORE_BATTLE_TARGET)
    e24:SetRange(LOCATION_MZONE)
    e24:SetCondition(aux.retcon2)
    e24:SetValue(aux.imval2)
    c:RegisterEffect(e24)
    local e25 = e24:Clone()
    e25:SetCode(EFFECT_CANNOT_BE_EFFECT_TARGET)
    e25:SetValue(aux.tgoval)
    c:RegisterEffect(e25)
    
    if form~=0 then
        -- Unstoppable Attack
        local e19 = Effect.CreateEffect(c)
        e19:SetType(EFFECT_TYPE_SINGLE)
        e19:SetCode(EFFECT_UNSTOPPABLE_ATTACK)
        e19:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE+EFFECT_FLAG_SINGLE_RANGE)
        e19:SetRange(LOCATION_MZONE)
        e19:SetCondition(aux.retcon3)
        c:RegisterEffect(e19)
    
        local e28 = Effect.CreateEffect(c)
        e28:SetType(EFFECT_TYPE_SINGLE)
        e28:SetCode(EFFECT_INDESTRUCTABLE_BATTLE)
        e28:SetValue(1)
        e28:SetCondition(aux.oatcon)
        c:RegisterEffect(e28)
        local e29 = Effect.CreateEffect(c)
        e29:SetType(EFFECT_TYPE_SINGLE)
        e29:SetCode(EFFECT_AVOID_BATTLE_DAMAGE)
        e29:SetValue(1)
        e29:SetCondition(aux.oatcon)
        c:RegisterEffect(e29)
        local e30 = e29:Clone()
        e30:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
        e30:SetRange(LOCATION_MZONE)
        e30:SetCode(EFFECT_IMMUNE_EFFECT)
        e30:SetValue(aux.eefilter)
        c:RegisterEffect(e30)

        local e31 = Effect.CreateEffect(c)
        e31:SetDescription(aux.Stringid(10000011, 0))
        e31:SetCategory(CATEGORY_ATKCHANGE)
        e31:SetType(EFFECT_TYPE_QUICK_O)
        e31:SetCode(EVENT_FREE_CHAIN)
        e31:SetRange(LOCATION_MZONE)
        e31:SetCountLimit(1)
        e31:SetCondition(aux.natcon)
        e31:SetCost(aux.otkcost2)
        e31:SetOperation(aux.otkop2)
        c:RegisterEffect(e31)
        
        -- 支付LP1000破坏对方场上所有怪兽
        local e32 = Effect.CreateEffect(c)
        e32:SetDescription(aux.Stringid(10000011, 1))
        e32:SetCategory(CATEGORY_DESTROY)
        e32:SetType(EFFECT_TYPE_QUICK_O)
        e32:SetCode(EVENT_FREE_CHAIN)
        e32:SetRange(LOCATION_MZONE)
        e32:SetCondition(aux.retcon32)
        e32:SetCost(aux.descost)
        e32:SetTarget(aux.destg)
        e32:SetOperation(aux.desop)
        c:RegisterEffect(e32)
        
        local e33 = Effect.CreateEffect(c)
        e33:SetDescription(aux.Stringid(708, 0))
        e33:SetCategory(CATEGORY_ATKCHANGE)
        e33:SetType(EFFECT_TYPE_QUICK_O)
        e33:SetCode(EVENT_FREE_CHAIN)
        e33:SetRange(LOCATION_MZONE)
        e33:SetCost(aux.otkcost)
        e33:SetCondition(aux.otkcon)
        e33:SetOperation(aux.otkop)
        c:RegisterEffect(e33)
    end
end

function aux.valcheck(e,c)
	local g=c:GetMaterial()
	  local tc=g:GetFirst()
	  local tatk=0
	  local tdef=0
	  while tc do
	  local atk=tc:GetAttack()
	  local def=tc:GetDefense()
	  if atk<0 then atk=0 end
	  if def<0 then def=0 end
	  tatk=tatk+atk 
	  tdef=tdef+def 
	  tc=g:GetNext() end
	Original_ATK=tatk
	Original_DEF=tdef
end
function aux.atkop(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	if c:GetMaterialCount()==0 then return end
	local e1 = Effect.CreateEffect(c)
	e1:SetType(EFFECT_TYPE_SINGLE)
	e1:SetCode(EFFECT_SET_ATTACK)
	e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
	e1:SetRange(LOCATION_MZONE)
	e1:SetValue(Original_ATK)
	e1:SetReset(RESET_EVENT + RESETS_STANDARD_DISABLE)
	c:RegisterEffect(e1)
	local e2 = e1:Clone()
	e2:SetCode(EFFECT_SET_DEFENSE)
	e2:SetValue(Original_DEF)
	c:RegisterEffect(e2)
end

function aux.ttcon2(e,c,minc,zone,relzone,exeff)
	if c==nil then return true end
	if exeff then
		local ret=exeff:GetValue()
		if type(ret)=="function" then
			ret={ret(exeff,c)}
			if #ret>1 then
				zone=(ret[2]>>16)&0x7f
			end
		end
	end
	local tp=c:GetControler()
	local mg=Duel.GetFieldGroup(tp,0,LOCATION_MZONE)
	mg=mg:Filter(Auxiliary.IsZone,nil,relzone,tp)
	return minc<=3 and Duel.CheckTribute(c,3,3,mg,1-tp,zone)
end
function aux.tttg2(e,tp,eg,ep,ev,re,r,rp,chk,c,minc,zone,relzone,exeff)
	if exeff then
		local ret=exeff:GetValue()
		if type(ret)=="function" then
			ret={ret(exeff,c)}
			if #ret>1 then
				zone=(ret[2]>>16)&0x7f
			end
		end
	end
	local mg=Duel.GetFieldGroup(tp,0,LOCATION_MZONE)
	mg=mg:Filter(Auxiliary.IsZone,nil,relzone,tp)
	local g=Duel.SelectTribute(tp,c,3,3,mg,1-tp,zone,true)
	if g and #g>0 then
		g:KeepAlive()
		e:SetLabelObject(g)
		return true
	end
	return false
end
function aux.ttop2(e,tp,eg,ep,ev,re,r,rp,c,minc,zone,relzone,exeff)
	local g=e:GetLabelObject()
	c:SetMaterial(g)
	Duel.Release(g,REASON_SUMMON+REASON_MATERIAL)
	g:DeleteGroup()
end

function aux.retop0(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetOwner()
	local ttp=e:GetHandler():GetControler()
	if Duel.IsEnvironment(10, ttp) or Duel.IsEnvironment(496, ttp) or Duel.GetFlagEffect(ttp, 7082) ~= 0 then return end
	if Duel.GetFlagEffect(1-ttp, 7081) == 0 then
		Duel.RegisterFlagEffect(1-ttp,7081,0,0,1)
		Duel.Hint(HINT_MESSAGE,1-ttp,aux.Stringid(708,6))
		local opt=Duel.AnnounceCard(1-ttp,TYPE_SPELL+TYPE_MONSTER+TYPE_TRAP,OPCODE_ALLOW_TOKENS)
		if opt==802 then
			Duel.RegisterFlagEffect(1-ttp,7082,0,0,1)
        elseif Duel.GetFlagEffect(1-ttp, 7081)~=0 and Duel.GetFlagEffect(1-ttp, 7082)==0 then
            Duel.Hint(HINT_MESSAGE,0,8096)
            Duel.Hint(HINT_MESSAGE,1,8096)
            Duel.Damage(ttp,9999999,REASON_RULE,true)
	        Duel.Damage(1-ttp,9999999,REASON_RULE,true)
	        Duel.RDComplete()
		end
	end
	if Duel.GetLocationCount(1-ttp,LOCATION_MZONE) < 1 or Duel.GetFlagEffect(1-ttp, 7082) == 0 or not Duel.SelectYesNo(1-ttp,aux.Stringid(11508758,0)) then return end

    local opt=Duel.SelectOption(1-ttp,aux.Stringid(825,0),aux.Stringid(825,1))
    if opt==0 then
        c:SetEntityCode(708,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
        aux.recover(c)
    else
        c:SetEntityCode(824,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
        aux.recover(c)
    end
	c:ResetEffect(EFFECT_CANNOT_CHANGE_CONTROL, RESET_CODE)
	Duel.GetControl(c, 1-ttp)
	local e100 = Effect.CreateEffect(c)
	e100:SetType(EFFECT_TYPE_SINGLE)
	e100:SetProperty(EFFECT_FLAG_SINGLE_RANGE + EFFECT_FLAG_CANNOT_DISABLE)
	e100:SetRange(LOCATION_MZONE)
	e100:SetCode(EFFECT_CANNOT_CHANGE_CONTROL)
	e100:SetValue(aux.retcon3)
	c:RegisterEffect(e100)
end
function aux.retop(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetOwner()
	local ttp=e:GetHandler():GetControler()
	if Duel.IsEnvironment(10, ttp) or Duel.IsEnvironment(496, ttp) or Duel.GetFlagEffect(ttp, 7082) ~= 0 then return end
	if Duel.GetFlagEffect(1-ttp, 7081) == 0 then
		Duel.RegisterFlagEffect(1-ttp,7081,0,0,1)
		Duel.Hint(HINT_MESSAGE,1-ttp,aux.Stringid(708,6))
		local opt=Duel.AnnounceCard(1-ttp,TYPE_SPELL+TYPE_MONSTER+TYPE_TRAP,OPCODE_ALLOW_TOKENS)
		if opt==802 then
			Duel.RegisterFlagEffect(1-ttp,7082,0,0,1)
        elseif Duel.GetFlagEffect(1-ttp, 7081)~=0 and Duel.GetFlagEffect(1-ttp, 7082)==0 then
            Duel.Hint(HINT_MESSAGE,0,8096)
            Duel.Hint(HINT_MESSAGE,1,8096)
            Duel.Damage(ttp,9999999,REASON_RULE,true)
	        Duel.Damage(1-ttp,9999999,REASON_RULE,true)
	        Duel.RDComplete()
		end
	end
	if Duel.GetLocationCount(1-ttp,LOCATION_MZONE) < 1 or Duel.GetFlagEffect(1-ttp, 7082) == 0 or not Duel.SelectYesNo(1-ttp,aux.Stringid(11508758,0)) then return end
	c:ResetEffect(EFFECT_CANNOT_CHANGE_CONTROL, RESET_CODE)
	Duel.GetControl(c, 1-ttp)
	local e100 = Effect.CreateEffect(c)
	e100:SetType(EFFECT_TYPE_SINGLE)
	e100:SetProperty(EFFECT_FLAG_SINGLE_RANGE + EFFECT_FLAG_CANNOT_DISABLE)
	e100:SetRange(LOCATION_MZONE)
	e100:SetCode(EFFECT_CANNOT_CHANGE_CONTROL)
	e100:SetValue(aux.retcon3)
	c:RegisterEffect(e100)
	if aux.isegg(c) then
		c:SetEntityCode(e:GetLabel(),nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
        aux.recover(c)
	end
end
function aux.retcon3(e,tp,eg,ep,ev,re,r,rp)
	return not aux.isegg(e:GetHandler())
    and e:GetHandler():GetGodLevel()>1
end

function aux.godlv0(e)
    local lv=e:GetOwner():GetGodLevel()
    return lv>0
end
function aux.godanime1(e)
    local label=e:GetLabel()
    local lv=e:GetOwner():GetGodLevel()
    return (label&1)~=0 and lv>0
end
function aux.godanime(e)
    local label=e:GetLabel()
    local lv=e:GetOwner():GetGodLevel()
    return (label&1)~=0 and lv>1
end
function aux.godmanga(e)
    local label=e:GetLabel()
    local lv=e:GetOwner():GetGodLevel()
    return (label&2)~=0 and lv>1
end

function aux.sumsuc0(e, tp, eg, ep, ev, re, r, rp)
    Duel.SetChainLimitTillChainEnd(aux.FALSE)
end
function aux.ssumsuc(e,tp,eg,ep,ev,re,r,rp)
    Duel.SetChainLimitTillChainEnd(aux.FALSE)
    local opt=Duel.SelectOption(e:GetHandlerPlayer(),aux.Stringid(821,0),aux.Stringid(821,1))
	if opt==0 then 
        Duel.SetChainLimitTillChainEnd(aux.FALSE)
		e:GetHandler():SetEntityCode(709,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
	else 
		e:GetHandler():SetEntityCode(822,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
	end
end
function aux.osumsuc(e,tp,eg,ep,ev,re,r,rp)
	local opt=Duel.SelectOption(e:GetHandlerPlayer(),aux.Stringid(818,0),aux.Stringid(818,1))	
	if opt==0 then
        Duel.SetChainLimitTillChainEnd(aux.FALSE)
		e:GetHandler():SetEntityCode(707,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true) 
	else 
		e:GetHandler():SetEntityCode(819,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true) 
	end	
end

function aux.lsumsuc(e,tp,eg,ep,ev,re,r,rp)
	Duel.SetChainLimitTillChainEnd(aux.FALSE)
	if e:GetHandler():IsSummonType(805) then
        local e8=Effect.CreateEffect(e:GetHandler())
        e8:SetType(EFFECT_TYPE_FIELD)
        e8:SetProperty(EFFECT_FLAG_PLAYER_TARGET)
        e8:SetCode(10000042)
        e8:SetTargetRange(0,1)
        e8:SetValue(1)
        e8:SetReset(RESET_CHAIN)
        Duel.RegisterEffect(e8,e:GetHandler():GetSummonPlayer())
        Duel.Win(e:GetHandler():GetSummonPlayer(),WIN_REASON_CREATORGOD)
    end
end

function aux.rsumsuccon(e, tp, eg, ep, ev, re, r, rp)
	local ttp2=e:GetHandler():GetControler()
	return Duel.IsEnvironment(496,ttp2)
end
function aux.rsumsuccon2(e, tp, eg, ep, ev, re, r, rp)
	local ttp2=e:GetHandler():GetControler()
	return not Duel.IsEnvironment(496,ttp2)
end
function aux.rsumsuc(e, tp, eg, ep, ev, re, r, rp)
	local c=e:GetHandler()
	local type=c:GetType()
    local form=e:GetLabel()
	local ttp=c:GetControler()
	--me oricha
	if Duel.IsEnvironment(10,ttp) or Duel.IsEnvironment(496,ttp) then
        if form==0 then
            local opt=Duel.SelectOption(ttp,aux.Stringid(825,0),aux.Stringid(825,1))
            if opt==0 then 
                Duel.SetChainLimitTillChainEnd(aux.FALSE)
                c:SetEntityCode(708,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
                aux.recover(c)
            else 
                c:SetEntityCode(824,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
                aux.recover(c)
            end
        end
        if not Duel.IsEnvironment(496,ttp) and c:IsSummonType(SUMMON_TYPE_SPECIAL) then
            aux.sumsuc3(c, ttp)
        end
		return
	end
    --not asked me before
    if Duel.GetFlagEffect(ttp, 7081)==0 then
        if Duel.GetFlagEffect(1-ttp, 7081)==0 then aux.toegg(c) end
        Duel.RegisterFlagEffect(ttp,7081,0,0,1)
        Duel.Hint(HINT_MESSAGE,ttp,aux.Stringid(708,6))
        local opt=Duel.AnnounceCard(ttp,TYPE_SPELL+TYPE_MONSTER+TYPE_TRAP,OPCODE_ALLOW_TOKENS)
        if opt==802 then
            Duel.RegisterFlagEffect(1-ttp,7082,0,0,1)
        elseif Duel.GetFlagEffect(1-ttp, 7081)~=0 and Duel.GetFlagEffect(1-ttp, 7082)==0 then
            Duel.Hint(HINT_MESSAGE,0,8096)
            Duel.Hint(HINT_MESSAGE,1,8096)
            Duel.Damage(ttp,9999999,REASON_RULE,true)
	        Duel.Damage(1-ttp,9999999,REASON_RULE,true)
	        Duel.RDComplete()
        end
    end
    --me own
    if Duel.GetFlagEffect(ttp, 7082)~=0 then
        local op = true
        if ttp == 1-e:GetHandler():GetControler() then
            op = false
        end
        if op then
            if form==0 then
                local opt=Duel.SelectOption(ttp,aux.Stringid(825,0),aux.Stringid(825,1))
                if opt==0 then
                    Duel.SetChainLimitTillChainEnd(aux.FALSE)
                    c:SetEntityCode(708,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
                    aux.recover(c)
                else 
                    c:SetEntityCode(824,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
                    aux.recover(c)
                end
            elseif aux.isegg(c) then
                local id=10000048
                if form==1 then id=708 end
                if form==2 then id=824 end
                if form==3 then id=83 end
                c:SetEntityCode(id,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
                aux.recover(c)
            end
            if not Duel.IsEnvironment(496,ttp) and c:IsSummonType(SUMMON_TYPE_SPECIAL) then
                aux.sumsuc3(c, ttp)
            end
        end
	end
end
function aux.sumsuc3(c,tp)
	if aux.isphoenix(c) or aux.isotk(c) or aux.isegg(c) then return end
	local off = 1
	local opt = {}
	opt[off] = aux.Stringid(824, 1)
    off = off + 1
	if not c:IsType(TYPE_FUSION) and Duel.GetLP(tp) > 1 then
		opt[off] = aux.Stringid(824, 0)
	end
	local op = Duel.SelectOption(tp, table.unpack(opt))
	if op==0 then
		aux.tophoenix(c)
		local e6 = Effect.CreateEffect(c)
		e6:SetDescription(aux.Stringid(10000011, 1))
		e6:SetCategory(CATEGORY_DESTROY)
		e6:SetType(EFFECT_TYPE_QUICK_O)
		e6:SetCode(EVENT_FREE_CHAIN)
		e6:SetRange(LOCATION_MZONE)
		e6:SetCost(aux.descost)
		e6:SetTarget(aux.destg)
		e6:SetOperation(aux.desop)
		e6:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
		c:RegisterEffect(e6)
	else
		aux.otkop3(c, tp)
	end
end

function aux.descost(e, tp, eg, ep, ev, re, r, rp, chk)
	if chk == 0 then
		return Duel.CheckLPCost(tp, 1000)
	end
	Duel.PayLPCost(tp, 1000)
end
function aux.destg(e, tp, eg, ep, ev, re, r, rp, chk)
	if chk == 0 then
		return Duel.IsExistingMatchingCard(nil, tp, 0, LOCATION_MZONE, 1, nil)
	end
	local g = Duel.GetMatchingGroup(nil, tp, 0, LOCATION_MZONE, nil)
	Duel.SetOperationInfo(0, CATEGORY_DESTROY, g, g:GetCount(), 0, 0)
end
function aux.desop(e, tp, eg, ep, ev, re, r, rp)
	local g = Duel.GetMatchingGroup(nil, tp, 0, LOCATION_MZONE, nil)
	Duel.Destroy(g, REASON_RULE+REASON_EFFECT)
end

function aux.otkop3(c, tp)
	if c:IsFaceup() and not c:IsType(TYPE_FUSION) then
		aux.tootk(c)
		local lp = Duel.GetLP(tp)
		Duel.SetLP(tp, 1)
		local val = lp - 1
		local e1 = Effect.CreateEffect(c)
		e1:SetType(EFFECT_TYPE_SINGLE)
		e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
		e1:SetRange(LOCATION_MZONE)
		e1:SetCode(EFFECT_UPDATE_ATTACK)
		e1:SetValue(val)
		e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
		c:RegisterEffect(e1)
		local e2 = e1:Clone()
		e2:SetCode(EFFECT_UPDATE_DEFENSE)
		c:RegisterEffect(e2)
	end
end

function aux.efop(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local eqc=eg:GetFirst()
    local ae={c:GetCardEffect(10000020)}
    for _,te in ipairs(ae) do
        te:Reset()
    end
    local e1 = Effect.CreateEffect(c)
    e1:SetType(EFFECT_TYPE_SINGLE)
    e1:SetCode(10000020)
    e1:SetLabelObject(eqc)
    e1:SetReset(RESET_EVENT + 0x1fe0000 - RESET_TOFIELD)
    c:RegisterEffect(e1, true)
end
function aux.tgcon(e, tp, eg, ep, ev, re, r, rp)
	return bit.band(e:GetHandler():GetSummonType(), SUMMON_TYPE_SPECIAL) == SUMMON_TYPE_SPECIAL
end
function aux.tgop(e, tp, eg, ep, ev, re, r, rp)
	local c = e:GetHandler()
    e:SetValue(1)
    local prevCtrl=c:GetPreviousControler()
    if c:IsPreviousLocation(LOCATION_GRAVE) then
        Duel.SendtoGrave(c,REASON_RULE+REASON_EFFECT,prevCtrl)
    elseif c:IsPreviousLocation(LOCATION_DECK) then
        Duel.SendtoDeck(c,prevCtrl,SEQ_DECKSHUFFLE,REASON_RULE+REASON_EFFECT)
    elseif c:IsPreviousLocation(LOCATION_HAND) then
        Duel.SendtoHand(c,prevCtrl,REASON_RULE+REASON_EFFECT)
    elseif c:IsPreviousLocation(LOCATION_REMOVED) then
        Duel.Remove(c,c:GetPreviousPosition(),REASON_RULE+REASON_EFFECT,prevCtrl)
    elseif c:GetPreviousLocation()==0 then
        Duel.RemoveCards(c)
    elseif c:IsPreviousLocation(LOCATION_SZONE) then
        Duel.MoveToField(c,tp,prevCtrl,LOCATION_SZONE,c:GetPreviousPosition(),true)
    elseif c:IsPreviousLocation(LOCATION_OVERLAY) then
        local ae={c:GetCardEffect(10000020)}
        for _,te in ipairs(ae) do
            local ac=te:GetLabelObject()
            if not ac or not ac:IsLocation(LOCATION_ONFIELD) then return end
            Duel.Overlay(ac,c)
        end
        for _,te in ipairs(ae) do
            te:Reset()
        end
    end
    e:SetValue(0)
end

function aux.efilterr(e, te)
	local c=e:GetHandler()
	local tc=te:GetOwner()
    local class=e:GetLabel()
    local tc_godlv = tc:GetGodLevel()
    local c_godlv = c:GetGodLevel()
	if tc==e:GetOwner() or te:IsHasProperty(EFFECT_FLAG_IGNORE_IMMUNE) then
		return false
	else
		if (class&2)==0 then
            return te:IsActiveType(TYPE_TRAP)
        else
            return (te:IsActiveType(TYPE_MONSTER)
                and ((tc_godlv==c_godlv and ((not tc:IsLevelAbove(c:GetLevel()) and tc:HasLevel()) or (not tc:IsRankAbove(c:GetLevel()) and tc:HasRank()) or (not tc:IsLinkAbove(c:GetLevel()) and tc:HasLink())))
                or c_godlv>tc_godlv))
        end
	end
end
function aux.chop(e,tp,eg,ep,ev,re,r,rp)
	local c=e:GetHandler()
	local tc=re:GetOwner()
    local class=e:GetLabel()
    local tc_godlv = tc:GetGodLevel()
    local c_godlv = c:GetGodLevel()
    if tc==e:GetOwner() or re:IsHasProperty(EFFECT_FLAG_IGNORE_IMMUNE) or (class&2)==0 then return end
	if re:IsActiveType(TYPE_TRAP) and Duel.GetCurrentChain()<2 then
		local e80 = Effect.CreateEffect(c)
        e80:SetType(EFFECT_TYPE_SINGLE)
        e80:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
        e80:SetRange(LOCATION_MZONE)
        e80:SetCode(EFFECT_IMMUNE_EFFECT)
        e80:SetValue(function(e, te2)
            return te2 == re
        end)
        e80:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
        c:RegisterEffect(e80)
        local g=Duel.GetChainInfo(ev,CHAININFO_TARGET_CARDS)
		local e4=Effect.CreateEffect(c)
		e4:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
		e4:SetCode(EVENT_CHAIN_SOLVED)
		e4:SetProperty(EFFECT_FLAG_CARD_TARGET+EFFECT_FLAG_DAMAGE_STEP+EFFECT_FLAG_DAMAGE_CAL)
		e4:SetRange(LOCATION_MZONE)
		e4:SetOperation(function(e,tp,eg,ep,ev,re,r,rp)
			if g and g:IsContains(c) and tc then
				tc:CancelCardTarget(c)
				tc:ReleaseRelation(c)
			end
		end)
		e4:SetReset(RESET_CHAIN)
		c:RegisterEffect(e4)
	end
end
function aux.reop2(e, tp, eg, ep, ev, re, r, rp)
    local c = e:GetHandler()
    local ae = {c:GetCardEffect()}
    for _, te in ipairs(ae) do
        if te:GetOwner() ~= e:GetOwner() then
            if te:GetType() == EFFECT_TYPE_FIELD then
                local e80 = Effect.CreateEffect(c)
                e80:SetType(EFFECT_TYPE_SINGLE)
                e80:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
                e80:SetRange(LOCATION_MZONE)
                e80:SetCode(EFFECT_IMMUNE_EFFECT)
                e80:SetValue(function(e, te2)
                    return te2 == te
                end)
                e80:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
                c:RegisterEffect(e80)
            elseif (te:GetType()==EFFECT_TYPE_SINGLE or te:GetType()==EFFECT_TYPE_EQUIP or te:GetType()==EFFECT_TYPE_GRANT or te:GetType()==EFFECT_TYPE_XMATERIAL)
            and not te:IsHasProperty(EFFECT_FLAG_IGNORE_IMMUNE) 
            and not te:GetOwner():IsHasEffect(EFFECT_ULTIMATE_IMMUNE) then
                te:Reset()
            end
        end
    end
end

function aux.econ(e)
    local ae=e:GetLabelObject()
	local c=e:GetOwner()
    local label=e:GetLabel()
    local lv=c:GetGodLevel()
    return ae:GetValue()==0
    and (label&1)~=0 and lv>1
end
function aux.econ2(e)
    local ae=e:GetLabelObject()
	local c=e:GetOwner()
    local label=e:GetLabel()
    local lv=c:GetGodLevel()
    return ae:GetValue()==0 and not aux.isotk(c)
    and (label&1)~=0 and lv>1
end

function aux.rellimit(e, c, tp, sumtp)
	return c == e:GetHandler()
end

function aux.retcon2(e, tp, eg, ep, ev, re, r, rp)
	return aux.isegg(e:GetHandler())
end

function aux.natcon(e)
	return (bit.band(e:GetHandler():GetSummonType(), SUMMON_TYPE_TRIBUTE) == SUMMON_TYPE_TRIBUTE or aux.isotk(e:GetHandler())) 
    and not aux.isegg(e:GetHandler())
end

function aux.oatcon(e)
	return aux.isphoenix(e:GetHandler()) and not aux.isegg(e:GetHandler())
end

function aux.atcon(e)
	return bit.band(e:GetHandler():GetSummonType(), SUMMON_TYPE_SPECIAL) == SUMMON_TYPE_SPECIAL and not aux.isegg(e:GetHandler())
end
function aux.atcon2(e, tp, eg, ep, ev, re, r, rp)
	local tc=Duel.GetAttacker()
	local tc2=Duel.GetAttackTarget()
	return bit.band(e:GetHandler():GetSummonType(), SUMMON_TYPE_SPECIAL) == SUMMON_TYPE_SPECIAL and not aux.isegg(e:GetHandler()) 
    and tc:IsFaceup() and tc:IsControler(1 - tp) and not tc:IsStatus(STATUS_ATTACK_CANCELED) and tc2 ~= e:GetHandler()
end
function aux.atop(e, tp, eg, ep, ev, re, r, rp)
	local tc=Duel.GetAttacker()
	local tc2=Duel.GetAttackTarget()
	if tc:IsFaceup() and tc:IsControler(1 - tp) and not tc:IsStatus(STATUS_ATTACK_CANCELED) and tc2 ~= e:GetHandler() then
		Duel.ChangeAttackTarget(e:GetHandler())
	end
end

function aux.eefilter(e, te)
	return te:GetOwner() ~= e:GetOwner()
end

function aux.repfilter(c, tc, tp)
	return c:IsControler(tp) and c ~= tc and c:IsLocation(LOCATION_MZONE) and
			   (c:IsReason(REASON_EFFECT) or c:IsReason(REASON_RULE)) and not c:IsReason(REASON_REPLACE)
end
function aux.reptg(e, tp, eg, ep, ev, re, r, rp, chk)
	if chk==0 then
		return eg:IsExists(aux.repfilter, 1, e:GetHandler(), e:GetHandler(), tp) and
				   not e:GetHandler():IsStatus(STATUS_DESTROY_CONFIRMED + STATUS_BATTLE_DESTROYED)
	end
	return Duel.SelectYesNo(tp, aux.Stringid(825, 3))
end
function aux.repval(e, c)
	return aux.repfilter(c, e:GetHandler(), e:GetHandlerPlayer())
end
function aux.repop(e, tp, eg, ep, ev, re, r, rp)
	Duel.Destroy(e:GetHandler(), REASON_RULE + REASON_REPLACE)
end

function aux.otkcost2(e, tp, eg, ep, ev, re, r, rp, chk)
	if chk==0 then
		return Duel.CheckReleaseGroup(tp, nil, 1, e:GetHandler())
	end
	local g = Duel.SelectReleaseGroup(tp, nil, 1, 99, e:GetHandler())
	local tc = g:GetFirst()
	local tatk = 0
	local tdef = 0
	while tc do
		local atk = tc:GetAttack()
		local def = tc:GetDefense()
		if atk < 0 then
			atk = 0
		end
		if def < 0 then
			def = 0
		end
		tatk = tatk + atk
		tdef = tdef + def
		tc = g:GetNext()
	end
	e:SetLabelObject({tatk,tdef})
	Duel.Release(g, REASON_COST)
end
function aux.otkop2(e, tp, eg, ep, ev, re, r, rp)
	local c=e:GetHandler()
	local tatk=e:GetLabelObject()[1]
	local tdef=e:GetLabelObject()[2]
	if c:IsFaceup() and c:IsRelateToEffect(e) then
		local e1 = Effect.CreateEffect(c)
		e1:SetType(EFFECT_TYPE_SINGLE)
		e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
		e1:SetRange(LOCATION_MZONE)
		e1:SetCode(EFFECT_UPDATE_ATTACK)
		e1:SetValue(tatk)
		e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
		c:RegisterEffect(e1)
		local e2 = e1:Clone()
		e2:SetCode(EFFECT_UPDATE_DEFENSE)
		e2:SetValue(tdef)
		c:RegisterEffect(e2)
	end
end

function aux.retcon32(e)
	return Duel.IsEnvironment(496,e:GetHandler():GetControler())
end

function aux.otkcost(e, tp, eg, ep, ev, re, r, rp, chk)
	if chk==0 then
		return Duel.GetLP(tp) > 1
	end
	local lp = Duel.GetLP(tp)
	Duel.SetLP(tp, 1)
	e:SetLabel(lp - 1)
end
function aux.otkcon(e, tp, eg, ep, ev, re, r, rp)
	local c=e:GetHandler()
	return not c:IsType(TYPE_FUSION) and Duel.IsEnvironment(496,tp)
end
function aux.otkop(e, tp, eg, ep, ev, re, r, rp)
	local c=e:GetHandler()
	if c:IsFaceup() and c:IsRelateToEffect(e) and not c:IsType(TYPE_FUSION) then
		aux.tootk(c)
		local e1 = Effect.CreateEffect(c)
		e1:SetType(EFFECT_TYPE_SINGLE)
		e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
		e1:SetRange(LOCATION_MZONE)
		e1:SetCode(EFFECT_UPDATE_ATTACK)
		e1:SetValue(e:GetLabel())
		e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
		c:RegisterEffect(e1)
		local e2 = e1:Clone()
		e2:SetCode(EFFECT_UPDATE_DEFENSE)
		c:RegisterEffect(e2)
	end
end

function aux.toegg(c)
	local e1 = Effect.CreateEffect(c)
    e1:SetDescription(aux.Stringid(708,8))
	e1:SetProperty(EFFECT_FLAG_CLIENT_HINT+EFFECT_FLAG_IGNORE_IMMUNE+EFFECT_FLAG_CANNOT_DISABLE)
	e1:SetType(EFFECT_TYPE_SINGLE)
	e1:SetCode(708)
	e1:SetValue(1)
	c:RegisterEffect(e1, true)
	c:SetCardData(CARDDATA_PICCODE,10000048)
end
function aux.isegg(c)
	local ae={c:IsHasEffect(708)}
	local chk=false
	if ae then
        for _, te in ipairs(ae) do
            if te:GetValue()==1 then
                chk=true
                break
            end
        end
	end
	return chk
end

function aux.isotk(c)
	local ae={c:IsHasEffect(708)}
	local chk=false
	if ae then
        for _, te in ipairs(ae) do
            if te:GetValue()==3 then
                chk=true
                break
            end
        end
	end
	return chk and c:IsType(TYPE_FUSION)
end
function aux.tootk(c)
	local code=c:GetOriginalCode()
	-- local cid=3
	-- if code==708 then cid=0 end
	-- if code==824 then cid=1 end
	-- if code==83 then cid=2 end
	local te1=c:SetCardData(CARDDATA_PICCODE,10000047,0,RESET_EVENT+RESETS_STANDARD_DISABLE,c)
	local te2=c:SetCardData(CARDDATA_TYPE,TYPE_MONSTER|TYPE_EFFECT|TYPE_FUSION,0,RESET_EVENT+RESETS_STANDARD_DISABLE,c)
	--c:RegisterFlagEffect(708,RESET_EVENT+RESETS_STANDARD_DISABLE,EFFECT_FLAG_CLIENT_HINT,1,code,aux.Stringid(825,cid))
	local e1=Effect.CreateEffect(c)
    e1:SetDescription(aux.Stringid(708,10))
	e1:SetProperty(EFFECT_FLAG_CLIENT_HINT+EFFECT_FLAG_IGNORE_IMMUNE)
	e1:SetType(EFFECT_TYPE_SINGLE)
	e1:SetCode(708)
	e1:SetValue(3)
	e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
	c:RegisterEffect(e1, true)
	-- local e8 = Effect.CreateEffect(c)
	-- e8:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE + EFFECT_FLAG_DAMAGE_STEP + EFFECT_FLAG_DAMAGE_CAL)
	-- e8:SetType(EFFECT_TYPE_SINGLE + EFFECT_TYPE_CONTINUOUS)
	-- e8:SetCode(EVENT_LEAVE_FIELD_P)
	-- e8:SetOperation(aux.recover)
	-- e8:SetReset(RESET_EVENT + 0x1fe0000)
	-- c:RegisterEffect(e8, true)
	local e4 = Effect.CreateEffect(c)
	e4:SetProperty(EFFECT_FLAG_DAMAGE_STEP+EFFECT_FLAG_DAMAGE_CAL)
	e4:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
	e4:SetCode(EVENT_ADJUST)
	e4:SetRange(LOCATION_MZONE)
	e4:SetCondition(aux.lpcon)
	e4:SetOperation(aux.lpop)
	e4:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
	c:RegisterEffect(e4)
    local e5=Effect.CreateEffect(c)
    e5:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e5:SetRange(LOCATION_MZONE)
    e5:SetCode(EFFECT_SEND_REPLACE)
    e5:SetType(EFFECT_TYPE_SINGLE+EFFECT_TYPE_CONTINUOUS)
    e5:SetTarget(aux.oreptg)
    e5:SetOperation(aux.orepop)
    e5:SetLabelObject({e4,te2,te1})
    e5:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
    c:RegisterEffect(e5)
	-- local e5 = Effect.CreateEffect(c)
	-- e5:SetProperty(EFFECT_FLAG_DAMAGE_STEP+EFFECT_FLAG_DAMAGE_CAL)
	-- e5:SetType(EFFECT_TYPE_FIELD+EFFECT_TYPE_CONTINUOUS)
	-- e5:SetRange(LOCATION_MZONE)
	-- e5:SetCode(EVENT_CHAINING)
	-- e5:SetLabelObject({e4,te2,te1})
	-- e5:SetCondition(aux.lpcon2)
	-- e5:SetOperation(aux.lpop2)
	-- e5:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
	-- c:RegisterEffect(e5)
end

function aux.lpcon(e, tp, eg, ep, ev, re, r, rp)
	local c = e:GetHandler()
	local ttp = c:GetControler()
	local lp = Duel.GetLP(ttp)
	return aux.isotk(c) and lp > 1
end
function aux.lpop(e, tp, eg, ep, ev, re, r, rp)
	local c = e:GetHandler()
	local ttp = c:GetControler()
	local lp = Duel.GetLP(ttp)
	if aux.isotk(c) and lp > 1 then
		Duel.SetLP(ttp, 1)
		local e1 = Effect.CreateEffect(c)
		e1:SetType(EFFECT_TYPE_SINGLE)
		e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
		e1:SetRange(LOCATION_MZONE)
		e1:SetCode(EFFECT_UPDATE_ATTACK)
		e1:SetValue(lp - 1)
		e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
		c:RegisterEffect(e1)
		local e2 = e1:Clone()
		e2:SetCode(EFFECT_UPDATE_DEFENSE)
		c:RegisterEffect(e2)
	end
end
function aux.oreptg1(e,tp,eg,ep,ev,re,r,rp,chk)
	local c=e:GetHandler()
    local label=e:GetLabel()
    local lv=c:GetGodLevel()
    local reasonsend=(not c:IsReason(REASON_BATTLE) and not c:IsReason(REASON_REPLACE) and not c:IsReason(REASON_RELEASE) and not c:IsReason(REASON_COST) and not c:IsReason(REASON_MATERIAL) and not c:IsReason(REASON_RULE)
        and re and e:GetOwner()~=re:GetOwner()
        and (label&1)~=0 and lv>1) --anime lv2
        and not aux.isotk(c)
	if chk==0 then return reasonsend end
	return reasonsend
end
function aux.oreptg(e,tp,eg,ep,ev,re,r,rp,chk)
	local c=e:GetHandler()
    local reasonsend=(not c:IsReason(REASON_BATTLE) and not c:IsReason(REASON_REPLACE) and not c:IsReason(REASON_COST) and not c:IsReason(REASON_MATERIAL) and not c:IsReason(REASON_RULE)
        and re and e:GetOwner()~=re:GetOwner())
	if chk==0 then return reasonsend end
	return Duel.SelectYesNo(tp,aux.Stringid(708,11))
end
function aux.orepop(e,tp,eg,ep,ev,re,r,rp)
	local c = e:GetHandler()
	local atk = c:GetAttack()
	if aux.isotk(c) then
        aux.recover(c,e:GetLabelObject())
        local e1 = Effect.CreateEffect(c)
        e1:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE)
        e1:SetType(EFFECT_TYPE_SINGLE)
        e1:SetCode(EFFECT_SET_ATTACK_FINAL)
        e1:SetValue(0)
        e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
        c:RegisterEffect(e1, true)
        local e2 = e1:Clone()
        e2:SetCode(EFFECT_SET_DEFENSE_FINAL)
        c:RegisterEffect(e2, true)
        Duel.Recover(tp, atk, REASON_EFFECT)
		e:Reset()
	end
end

function aux.lpcon2(e, tp, eg, ep, ev, re, r, rp)
	local c = e:GetHandler()
	return aux.isotk(c) and re:GetHandler():IsCode(95286165)
end
function aux.lpop2(e, tp, eg, ep, ev, re, r, rp)
	local c = e:GetHandler()
	local ttp = c:GetControler()
	local atk = c:GetAttack()
	if aux.isotk(c) and re:GetHandler():IsCode(95286165) then
        aux.recover(c,e:GetLabelObject())
		Duel.ChangeChainOperation(0,function(e, tp, eg, ep, ev, re, r, rp)
            local e1 = Effect.CreateEffect(c)
            e1:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE)
            e1:SetType(EFFECT_TYPE_SINGLE)
            e1:SetCode(EFFECT_SET_ATTACK_FINAL)
            e1:SetValue(0)
            e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
            c:RegisterEffect(e1, true)
            local e2 = e1:Clone()
            e2:SetCode(EFFECT_SET_DEFENSE_FINAL)
            c:RegisterEffect(e2, true)
            Duel.Recover(ttp, atk, REASON_EFFECT)
		end)
		e:Reset()
	end
end

function aux.tophoenix(c)
	local code=c:GetOriginalCode()
	-- local cid=3
	-- if code==708 then cid=0 end
	-- if code==824 then cid=1 end
	-- if code==83 then cid=2 end
	c:SetCardData(CARDDATA_PICCODE,10000049,0,RESET_EVENT+RESETS_STANDARD_DISABLE,c)
	--c:RegisterFlagEffect(708,RESET_EVENT+RESETS_STANDARD_DISABLE,EFFECT_FLAG_CLIENT_HINT,1,code,aux.Stringid(825,cid))
	local e1 = Effect.CreateEffect(c)
    e1:SetDescription(aux.Stringid(708,9))
	e1:SetProperty(EFFECT_FLAG_CLIENT_HINT+EFFECT_FLAG_IGNORE_IMMUNE)
	e1:SetType(EFFECT_TYPE_SINGLE)
	e1:SetCode(708)
	e1:SetValue(2)
	e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE)
	c:RegisterEffect(e1, true)
	-- local e8 = Effect.CreateEffect(c)
	-- e8:SetProperty(EFFECT_FLAG_IGNORE_IMMUNE + EFFECT_FLAG_DAMAGE_STEP + EFFECT_FLAG_DAMAGE_CAL)
	-- e8:SetType(EFFECT_TYPE_SINGLE + EFFECT_TYPE_CONTINUOUS)
	-- e8:SetCode(EVENT_LEAVE_FIELD_P)
	-- e8:SetOperation(aux.recover)
	-- e8:SetReset(RESET_EVENT + 0x1fe0000)
	-- c:RegisterEffect(e8, true)
end
function aux.isphoenix(c)
	local ae={c:IsHasEffect(708)}
	local chk=false
    if ae then
        for _, te in ipairs(ae) do
            if te:GetValue()==2 then
                chk=true
                break
            end
        end
	end
	return chk
end
function aux.recover(c,se)
	if aux.isegg(c) then
        local ae={c:IsHasEffect(708)}
        if ae then
            for _, te in ipairs(ae) do
                te:Reset()
            end
        end
	end
	if (aux.isphoenix(c) or aux.isotk(c)) and se then
    --and ocode and (ocode == 708 or ocode == 824 or ocode == 83) then
		--c:SetEntityCode(ocode,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,nil,true)
		--c:ResetFlagEffect(708)
        local ae={c:IsHasEffect(708)}
        if ae then
            for _, te in ipairs(ae) do
                te:Reset()
            end
        end
        for _, te in ipairs(se) do
            te:Reset()
        end
	end
end

---------------------------------------------------------------------------------------------------------------
function aux.adval(e, c)
    return Duel.GetFieldGroupCount(c:GetControler(), LOCATION_HAND, 0) * 1000
end

function aux.satkfilter(c,tp,e)
    return c:IsControler(tp) and c:IsFaceup() and c:IsCanBeEffectTarget(e)
end
function aux.satktg(e, tp, eg, ep, ev, re, r, rp, chk, chkc)
	if chkc then return eg:IsContains(chkc) and aux.satkfilter(chkc,1-tp,e) end
    if chk == 0 then
        return eg:IsExists(aux.satkfilter,1,nil,1-tp,e)
    end
    Duel.SetTargetCard(eg:Filter(aux.satkfilter,nil,1-tp,e))
end
function aux.satkop(e, tp, eg, ep, ev, re, r, rp)
    local g=Duel.GetTargetCards(e):Filter(Card.IsFaceup,nil)
	if #g==0 then return end
    local dg = Group.CreateGroup()
    local c = e:GetHandler()
    if g:GetCount() > 0 then
        local tc = g:GetFirst()
        while tc do
            local preatk = tc:GetAttack()
            local predef = tc:GetDefense()
            if tc:GetPosition() == POS_FACEUP_ATTACK and preatk > 0 then
                local e1 = Effect.CreateEffect(c)
                e1:SetType(EFFECT_TYPE_SINGLE)
                e1:SetCode(EFFECT_UPDATE_ATTACK)
                e1:SetValue(-2000)
                e1:SetReset(RESET_EVENT + 0x1fe0000)
                tc:RegisterEffect(e1)
                if tc:GetAttack() == 0 then
                    dg:AddCard(tc)
                end
            end

            if tc:GetPosition() == POS_FACEUP_DEFENSE and predef > 0 then
                local e1 = Effect.CreateEffect(c)
                e1:SetType(EFFECT_TYPE_SINGLE)
                e1:SetCode(EFFECT_UPDATE_DEFENSE)
                e1:SetValue(-2000)
                e1:SetReset(RESET_EVENT + 0x1fe0000)
                tc:RegisterEffect(e1)
                if tc:GetDefense() == 0 then
                    dg:AddCard(tc)
                end
            end
            tc = g:GetNext()
        end
        Duel.Destroy(dg, REASON_RULE+REASON_EFFECT)
    end
end
-----------------------------------------------------------------------------------------------------------------
function aux.odescost(e, tp, eg, ep, ev, re, r, rp, chk)
    if chk == 0 then
        return Duel.CheckReleaseGroup(tp, nil, 2, e:GetHandler())
    end
    local g = Duel.SelectReleaseGroup(tp, nil, 2, 2, e:GetHandler())
    Duel.Release(g, REASON_COST)
end

function aux.ofilter(c, atk)
    return ((c:IsPosition(POS_FACEUP_ATTACK) and c:GetAttack() < atk) or
               (c:IsPosition(POS_FACEUP_DEFENSE) and c:GetDefense() < atk) or c:IsFacedown())
end
function aux.odestg(e, tp, eg, ep, ev, re, r, rp, chk)
    local c = e:GetHandler()
    local atk = c:GetAttack()
    if chk == 0 then
        return Duel.IsExistingMatchingCard(aux.ofilter, tp, 0, LOCATION_MZONE, 1, nil, atk)
    end
    local g = Duel.GetMatchingGroup(aux.ofilter, tp, 0, LOCATION_MZONE, nil, atk)
    Duel.SetOperationInfo(0, CATEGORY_DESTROY, g, g:GetCount(), 0, 0)
end
function aux.odesop(e, tp, eg, ep, ev, re, r, rp)
    local c = e:GetHandler()
    local atk = c:GetAttack()
    local g = Duel.GetMatchingGroup(aux.ofilter, tp, 0, LOCATION_MZONE, nil, atk)
    Duel.Hint(HINT_ANIME, tp, aux.Stringid(828, 0))
    Duel.Destroy(g, REASON_RULE+REASON_EFFECT)
    local e1 = Effect.CreateEffect(c)
    e1:SetType(EFFECT_TYPE_SINGLE)
    e1:SetProperty(EFFECT_FLAG_SINGLE_RANGE)
    e1:SetCode(EFFECT_DIRECT_ATTACK)
    e1:SetRange(LOCATION_MZONE)
    e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE + RESET_PHASE + PHASE_END)
    c:RegisterEffect(e1)
end

function aux.oatkcon(e, tp, eg, ep, ev, re, r, rp)
    local ph = Duel.GetCurrentPhase()
    return (ph >= PHASE_BATTLE_START and ph <= PHASE_BATTLE)
end
function aux.oatkcost(e, tp, eg, ep, ev, re, r, rp, chk)
    if chk == 0 then
        return Duel.CheckReleaseGroup(tp, Card.IsAttribute, 2, e:GetHandler(), ATTRIBUTE_DIVINE)
    end
    local g = Duel.SelectReleaseGroup(tp, Card.IsAttribute, 2, 2, e:GetHandler(), ATTRIBUTE_DIVINE)
    Duel.Release(g, REASON_COST)
    local e1 = Effect.CreateEffect(e:GetHandler())
    e1:SetType(EFFECT_TYPE_FIELD)
    e1:SetCode(EFFECT_CANNOT_ATTACK)
    e1:SetProperty(EFFECT_FLAG_OATH)
    e1:SetTargetRange(LOCATION_MZONE, 0)
    e1:SetTarget(aux.oftarget)
    e1:SetLabel(e:GetHandler():GetFieldID())
    e1:SetReset(RESET_PHASE + PHASE_END)
    Duel.RegisterEffect(e1, tp)
end
function aux.oftarget(e, c)
    return e:GetLabel() ~= c:GetFieldID()
end
function aux.oatkop(e, tp, eg, ep, ev, re, r, rp)
    local c = e:GetHandler()
    if c:IsFacedown() or not c:IsRelateToEffect(e) then
        return
    end
    local e1 = Effect.CreateEffect(c)
    e1:SetType(EFFECT_TYPE_SINGLE)
    e1:SetCode(EFFECT_INF_ATTACK)
    e1:SetReset(RESET_EVENT+RESETS_STANDARD_DISABLE+RESET_PHASE+PHASE_END)
    c:RegisterEffect(e1)
    Duel.Hint(HINT_ANIME, tp, aux.Stringid(828, 1))
end


--zdiy--
--ygo function
function Auxiliary.nbcon(tp,re)
	local rc=re:GetHandler()
	return Duel.IsPlayerCanRemove(tp)
		and (not rc:IsRelateToEffect(re) or rc:IsAbleToRemove())
end

function Auxiliary.ExceptThisCard(e)
	local c=e:GetHandler()
	if c:IsRelateToChain() then return c else return nil end
end
--ygo function
--zdiy--

function Auxiliary.SwapEntity(g1, g2)
    if not g1 or not g2 then return end
    if type(g1)~=type(g1) then return end
    if type(g1)=="Group" then
        if #g1~=#g2 or #g1==0 then return end
        for tc in aux.Next(g1) do
            local tac=g2:GetFirst()
            g2:RemoveCard(tac)
            local code1=tc:GetOriginalCode()
            local code2=tac:GetOriginalCode()
            if code1==code2 then return end
            tc:SetEntityCode(code2, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, true)
            aux.CopyCardTable(code2,tc)
            tac:SetEntityCode(code1, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, true)
            aux.CopyCardTable(code1,tac)
        end
    else
        local code1=g1:GetOriginalCode()
        local code2=g2:GetOriginalCode()
        if code1==code2 then return end
        g1:SetEntityCode(code2, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, true)
        aux.CopyCardTable(code2,g1)
        g2:SetEntityCode(code1, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, true)
        aux.CopyCardTable(code1,g2)
    end
end

function Auxiliary.mix_twosetcodes(c1, c2)
    local setnames1 = {c1:GetOriginalSetCard()}
    local setnames2 = {c2:GetOriginalSetCard()}
    local ss = {}
    local ss_count = 0
    local ss_extra = {}
    for _, setcode in ipairs(setnames1) do
        for index, setcode2 in ipairs(setnames2) do
            if (setcode2 & 0xffff) == (setcode & 0xffff) then
                table.remove(setnames2, index)
            elseif (setcode2 & 0xff) == (setcode & 0xff) 
            and not ((setcode & 0xff) == 0x48 and setcode ~= 0x48 and (setcode2 & 0xff) == 0x48 and setcode2 ~= 0x48) then
                setcode = setcode | setcode2
                table.remove(setnames2, index)
            end
        end
        ss_count = ss_count + 1
        if ss_count > 4 then
            table.insert(ss_extra, setcode)
        else
            table.insert(ss, setcode)
        end
    end
    for _, setcode in ipairs(setnames2) do
        ss_count = ss_count + 1
        if ss_count > 4 then
            table.insert(ss_extra, setcode)
        else
            table.insert(ss, setcode)
        end
    end
    for _, setcode in ipairs(ss_extra) do
        local e1=Effect.CreateEffect(c2)
        e1:SetType(EFFECT_TYPE_SINGLE)
        e1:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
        e1:SetCode(EFFECT_ADD_SETCODE)
        e1:SetValue(setcode)
        c2:RegisterEffect(e1)
    end
    return ss
end

function Auxiliary.extraobjfromtable2(table1,table2)
    local tab={}
    local len=0
    for cindex,name in ipairs(table2) do
        for index,value in ipairs(table1) do
            if value==name then --if table1 already has element name, not need add name to table1
                table.remove(table2,cindex)
            end
        end
        table.insert(tab,name)
        len=len+1
    end
    return tab,len
end
function Auxiliary.addtobigtable(table1,bigtable,bigtable2,k)
    local has_listed_table=false
    for k2,tab2 in pairs(bigtable) do
        if k2==k then
            has_listed_table=true
            local ntab2=aux.extraobjfromtable2(tab2,table1) --add table1(already remove obj exist in bigtable) to ntab2
            for index2,value2 in ipairs(ntab2) do
                table.insert(bigtable2,value2)
            end
            break
        end
    end
    if not has_listed_table then bigtable2[k]=table1 end
end
function Auxiliary.CopyCardTable(c,tc,merge,list,...)
    if type(c)~="number" and type(c)~="Card" then error("Parameter 1 should be \"number\" or \"Card\"",2) end
    local card_names={...}
    local listed_names_chk=false
    if #card_names>0 then listed_names_chk=true end
    local otcode=tc:GetOriginalCode()
    if not _G["c" .. otcode] then otcode=tc:GetOriginalAlias() end
    if not _G["c" .. otcode] then return end
    local ocode=0
    if type(c)~="number" then
        ocode=c:GetOriginalCode()
        if not _G["c" .. ocode] then ocode=c:GetOriginalAlias() end
    else
        ocode=c
    end
    if not _G["c" .. ocode] then _G["c" .. ocode]={} end
    for k,tab in pairs(_G["c" .. ocode]) do --check every c table
        if listed_names_chk and k==list then --if c table has table list
            has_listed_names_table=true
            local ntab,ntab_len=aux.extraobjfromtable2(tab,card_names) --add card_names(already remove obj exist in tab) to ntab
            for index, value in ipairs(tab) do --add c table k to ntab
                table.insert(ntab,value)
            end
            --ntab: to be added to tc table
            if ntab_len>0 then
                if merge then
                    aux.addtobigtable(ntab,_G["c" .. otcode],tc.__index,k)
                else
                    tc.__index[k]=ntab
                end
            end
        else
            if merge then
                local has_listed_table=false
                for k2,tab2 in pairs(_G["c" .. otcode]) do
                    if k2==k then
                        has_listed_table=true
                        if type(tc.__index[k])=="table" then
                            local ntab=aux.extraobjfromtable2(tab2,tab)
                            for index,value in ipairs(ntab) do
                                table.insert(tc.__index[k],value)
                            end
                        else
                            if tab2~=tab then tc.__index[k]=tab end
                        end
                    end
                end
                if not has_listed_table then
                    tc.__index[k]=tab
                end
            else
                tc.__index[k]=tab
            end
        end
    end
    if not has_listed_names_table and listed_names_chk then 
        tc.__index[list]=card_names
    end
end

function Auxiliary.xyzchange(xyz, tc)
    local code = tc:GetOriginalCode()
    local realcode = xyz:GetOriginalCode()
    local ss = aux.mix_twosetcodes(tc, xyz)
    local schange = 0xcf
    local atk = tc:GetTextAttack()
    if realcode == 620 then
        schange = 0x548
        atk = atk + 1
    end
    xyz:SetEntityCode(code, nil, ss, nil, nil, nil, nil, atk, nil, nil, nil, nil, false, realcode, realcode, realcode)
    aux.CopyCardTable(tc,xyz)
end

function Auxiliary.GetValueType(v)
    local t = type(v)
    if t == "userdata" then
        local mt = getmetatable(v)
        if mt == Group then
            return "Group"
        elseif mt == Effect then
            return "Effect"
        else
            return "Card"
        end
    else
        return t
    end
end

--Summon procedure
function Xyz.AddProcedureX(c,f,lv,ct,alterf,desc,maxct,op,mustbemat,exchk)
	--exchk for special xyz, checking other materials
	--mustbemat for Startime Magician
	if not maxct then maxct=ct end
	if maxct==99 then
		maxct=Xyz.InfiniteMats
		Debug.PrintStacktrace()
		Debug.Message("Using 99 to represent any number of Xyz materials is deprecated, use the value Xyz.InfiniteMats instead")
	end
	if c.xyz_filter==nil then
		local mt=c:GetMetatable()
		mt.xyz_filter=function(mc,ignoretoken,xyz,tp) return mc and (not f or f(mc,xyz,SUMMON_TYPE_XYZ|MATERIAL_XYZ,tp)) and (not lv or mc:IsXyzLevel(c,lv)) and (not mc:IsType(TYPE_TOKEN) or ignoretoken) end
		mt.xyz_parameters={mt.xyz_filter,lv,ct,alterf,desc,maxct,op,mustbemat,exchk}
		mt.minxyzct=ct
		mt.maxxyzct=maxct
	end

	local chk1=Effect.CreateEffect(c)
	chk1:SetType(EFFECT_TYPE_SINGLE)
	chk1:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_IGNORE_IMMUNE+EFFECT_FLAG_SET_AVAILABLE)
	chk1:SetCode(946)
	chk1:SetCondition(Xyz.Condition(f,lv,ct,maxct,mustbemat,exchk))
	chk1:SetTarget(Xyz.Target(f,lv,ct,maxct,mustbemat,exchk))
	chk1:SetOperation(Xyz.OperationX(f,lv,ct,maxct,mustbemat,exchk))
	c:RegisterEffect(chk1)
	local e1=Effect.CreateEffect(c)
	e1:SetType(EFFECT_TYPE_FIELD)
	e1:SetDescription(1173)
	e1:SetCode(EFFECT_SPSUMMON_PROC)
	e1:SetProperty(EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_UNCOPYABLE)
	e1:SetRange(LOCATION_EXTRA)
	e1:SetCondition(Xyz.Condition(f,lv,ct,maxct,mustbemat,exchk))
	e1:SetTarget(Xyz.Target(f,lv,ct,maxct,mustbemat,exchk))
	e1:SetOperation(Xyz.OperationX(f,lv,ct,maxct,mustbemat,exchk))
	e1:SetValue(SUMMON_TYPE_XYZ)
	e1:SetLabelObject(chk1)
	c:RegisterEffect(e1)
	if alterf then
		local chk2=chk1:Clone()
		chk2:SetDescription(desc)
		chk2:SetCondition(Xyz.Condition2(alterf,op))
		chk2:SetTarget(Xyz.Target2(alterf,op))
		chk2:SetOperation(Xyz.Operation2(alterf,op))
		c:RegisterEffect(chk2)
		local e2=e1:Clone()
		e2:SetDescription(desc)
		e2:SetCondition(Xyz.Condition2(alterf,op))
		e2:SetTarget(Xyz.Target2(alterf,op))
		e2:SetOperation(Xyz.Operation2(alterf,op))
		c:RegisterEffect(e2)
	end
end
function Xyz.OperationX(f, lv, minc, maxc, mustbemat, exchk)
	return  function(e,tp,eg,ep,ev,re,r,rp,c,must,og,min,max)
        local g=e:GetLabelObject()
        if not g then return end
        local remg=g:Filter(Card.IsHasEffect,nil,EFFECT_ORICHALCUM_CHAIN)
        remg:ForEach(function(c) c:RegisterFlagEffect(511002115,RESET_EVENT+RESETS_STANDARD,0,0) end)
        g:Remove(Card.IsHasEffect,nil,EFFECT_ORICHALCUM_CHAIN):Remove(Card.IsHasEffect,nil,511002115)

        local xg=Group.CreateGroup()
        for tc in aux.Next(g) do
            xg:Merge(tc:GetOverlayGroup())
        end
        g:Merge(xg)
        Duel.Overlay(c,xg,true)

        c:SetMaterial(g)
        Duel.Overlay(c,g,true)
        g:DeleteGroup()
    end
end

function Synchro.DarkCheck2(sg,card1,card2,plv,nlv,sc,tp,f1,f2,...)
	if sg:IsExists(Synchro.CheckHand,1,nil,sg) then return false end
	--[[local c=sg:GetFirst()
	while c do
		if c:IsHasEffect(EFFECT_HAND_SYNCHRO+EFFECT_SYNCHRO_CHECK) then
			local teg={c:GetCardEffect(EFFECT_HAND_SYNCHRO+EFFECT_SYNCHRO_CHECK)}
			local hanchk=false
			for i=1,#teg do
				local te=teg[i]
				local tgchk=te:GetTarget()
				local res=tgchk(te,c,sg,Group.CreateGroup(),Group.CreateGroup(),Group.CreateGroup(),Group.CreateGroup())
				--if not res then return false end
				if res then
					hanchk=true
					break
				end
			end
			if not hanchk then return false end
		end
		c=sg:GetNext()
	end]]
	local reqm={...}
    if (f1 and not f1(card1,sc,SUMMON_TYPE_SYNCHRO|MATERIAL_SYNCHRO,tp)) or (f2 and not f2(card2,sc,SUMMON_TYPE_SYNCHRO|MATERIAL_SYNCHRO,tp)) or not card2:IsType(TYPE_TUNER,sc,SUMMON_TYPE_SYNCHRO|MATERIAL_SYNCHRO,tp) or not card2:IsSetCard(0x600) then return false end
	local lvchk=false
	for _,reqmat in ipairs(reqm) do
		if not reqmat(sg,sc,tp) then return false end
	end
    if sg:IsExists(Card.IsHasEffect,1,nil,EFFECT_SYNCHRO_MATERIAL_CUSTOM) then
		local g=sg:Filter(Card.IsHasEffect,nil,EFFECT_SYNCHRO_MATERIAL_CUSTOM)
		for tc in aux.Next(g) do
			local teg={tc:GetCardEffect(EFFECT_SYNCHRO_MATERIAL_CUSTOM)}
			for _,te in ipairs(teg) do
				local op=te:GetOperation()
				local ok,tlvchk=op(te,Group.CreateGroup(),Group.CreateGroup(),sg,plv,sc,tp,nlv,card1,card2)
				if not ok then return false end
				lvchk=lvchk or tlvchk
			end
		end
	end
	if Synchro.CheckAdditional and not Synchro.CheckAdditional(tp,sg,sc) then return false end
	if sc:IsLocation(LOCATION_EXTRA) then
		if Duel.GetLocationCountFromEx(tp,tp,sg,sc)<=0 then return false end
	else
		if Duel.GetMZoneCount(tp,sg,tp)<=0 then return false end
	end
	if lvchk then return true end
	local ntlv=card1:GetSynchroLevel(sc)
	local ntlv1=ntlv&0xffff
	local ntlv2=ntlv>>16
	local tlv=card2:GetSynchroLevel(sc)
	local tlv1=tlv&0xffff
	local tlv2=tlv>>16
	if card1:GetFlagEffect(100000147)>0 then
        ----------kdiy---------
        -- if tlv1==nlv-ntlv1 then return true end
		-- if (tlv2>0 or card2:IsStatus(STATUS_NO_LEVEL)) and (ntlv2>0 or card1:IsStatus(STATUS_NO_LEVEL)) then
		-- 	return tlv2==nlv-ntlv1 or tlv1==nlv-ntlv2 or tlv2==nlv-ntlv2
		-- elseif tlv2>0 or card2:IsStatus(STATUS_NO_LEVEL) then
		-- 	return tlv2==nlv-ntlv1
		-- elseif ntlv2>0 or card1:IsStatus(STATUS_NO_LEVEL) then
		-- 	return tlv1==nlv-ntlv2
		-- end
        if tlv == plv - ntlv then
            return true
        end
        ----------kdiy---------
        return false
    else
        ----------kdiy---------
        -- if tlv1==plv+ntlv1 then return true end
		-- if (tlv2>0 or card2:IsStatus(STATUS_NO_LEVEL)) and (ntlv2>0 or card1:IsStatus(STATUS_NO_LEVEL)) then
		-- 	return tlv2==plv+ntlv1 or tlv1==plv+ntlv2 or tlv2==plv+ntlv2
		-- elseif tlv2>0 or card2:IsStatus(STATUS_NO_LEVEL) then
		-- 	return tlv2==nlv-ntlv1
		-- elseif ntlv2>0 or card1:IsStatus(STATUS_NO_LEVEL) then
		-- 	return tlv1==nlv-ntlv2
		-- end
        if tlv == plv + ntlv then
            return true
        end
        ----------kdiy---------
        return false
    end
end

Ritual.AddProcEqual = aux.FunctionWithNamedArgs(
function(c,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
	return Ritual.AddProc(c,RITPROC_EQUAL,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
end,"handler","filter","lv","desc","extrafil","extraop","matfilter","stage2","location","forcedselection","customoperation","specificmatfilter","requirementfunc","sumpos","extratg","self","range","con","cost")
Ritual.AddProc = aux.FunctionWithNamedArgs(
function(c,_type,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
	local e1=Ritual.CreateProc(c,_type,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
	c:RegisterEffect(e1)
	return e1
end,"handler","lvtype","filter","lv","desc","extrafil","extraop","matfilter","stage2","location","forcedselection","customoperation","specificmatfilter","requirementfunc","sumpos","extratg","self","range","con","cost")
--Ritual Summon, geq fixed lv
Ritual.AddProcGreater = aux.FunctionWithNamedArgs(
function(c,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
	return Ritual.AddProc(c,RITPROC_GREATER,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
end,"handler","filter","lv","desc","extrafil","extraop","matfilter","stage2","location","forcedselection","customoperation","specificmatfilter","requirementfunc","sumpos","extratg","self","range","con","cost")
--Ritual Summon
Ritual.CreateProc = aux.FunctionWithNamedArgs(
function(c,_type,filter,lv,desc,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,extratg,self,range,con,cost)
	--lv can be a function (like GetLevel/GetOriginalLevel), fixed level, if nil it defaults to GetLevel
	if filter and type(filter)=="function" then
		local mt=c.__index
		if not mt.ritual_matching_function then
			mt.ritual_matching_function={}
		end
		mt.ritual_matching_function[c]=filter
	end
	local e1=Effect.CreateEffect(c)
	if desc then
		e1:SetDescription(desc)
	else
		e1:SetDescription(1171)
	end
	e1:SetCategory(CATEGORY_SPECIAL_SUMMON)
    if range then
        e1:SetType(EFFECT_TYPE_IGNITION)
	else
        e1:SetType(EFFECT_TYPE_ACTIVATE)
        e1:SetCode(EVENT_FREE_CHAIN)
    end
    if range then e1:SetRange(range) end
    if con then e1:SetCondition(con) end
	if cost then e1:SetCost(cost) end
	e1:SetTarget(Ritual.Target(filter,_type,lv,extrafil,extraop,matfilter,stage2,location,forcedselection,specificmatfilter,requirementfunc,sumpos,extratg,self))
	e1:SetOperation(Ritual.Operation(filter,_type,lv,extrafil,extraop,matfilter,stage2,location,forcedselection,customoperation,specificmatfilter,requirementfunc,sumpos,self))
	return e1
end,"handler","lvtype","filter","lv","desc","extrafil","extraop","matfilter","stage2","location","forcedselection","customoperation","specificmatfilter","requirementfunc","sumpos","extratg","self","range","con","cost")


-- for additional registers
Card.RegisterEffect=(function()
	local oldf=Card.RegisterEffect
	local function map_to_effect_code(val)
		if val==1 then return 511002571	end -- access to effects that activate that detach an Xyz Material as cost
		if val==2 then return 511001692 end -- access to Cardian Summoning conditions/effects
		if val==4 then return  12081875 end -- access to Thunder Dragon effects that activate by discarding
		if val==8 then return 511310036	end -- access to Allure Queen effects that activate by sending themselves to GY
		if val==16 then return 58858807 end -- access to tellarknights/constellar effects that activate when Normal Summoned
        if val==32 then return 4965193 end -- access to Dragon Ruler effects that activate by discarding
		return nil
	end
	return function(c,e,forced,...)
		local reg_e=oldf(c,e,forced)
		if not reg_e or reg_e<=0 then return reg_e end
		local resetflag,resetcount=e:GetReset()
		for _,val in ipairs{...} do
			local code=map_to_effect_code(val)
			if code then
				local prop=EFFECT_FLAG_CANNOT_DISABLE+EFFECT_FLAG_IGNORE_IMMUNE+EFFECT_FLAG_SET_AVAILABLE
				if e:IsHasProperty(EFFECT_FLAG_UNCOPYABLE) then prop=prop|EFFECT_FLAG_UNCOPYABLE end
				local e2=Effect.CreateEffect(c)
				e2:SetType(EFFECT_TYPE_SINGLE)
				e2:SetProperty(prop,EFFECT_FLAG2_MAJESTIC_MUST_COPY)
				e2:SetCode(code)
				e2:SetLabelObject(e)
				e2:SetLabel(c:GetOriginalCode())
				if resetflag and resetcount then
					e2:SetReset(resetflag,resetcount)
				elseif resetflag then
					e2:SetReset(resetflag)
				end
				c:RegisterEffect(e2)
			end
		end

        if c:IsType(TYPE_SKILL) and e:GetCode()==EVENT_STARTUP then
            local mt=c:GetMetatable()
            if not mt then return end
            if mt.startop == nil then
                mt.startop = {e}
            else
                table.insert(mt.startop, e)
            end
        end

		return reg_e
	end
end)()

--Custom Setname
function Card.IsArcana(c)
    return c:IsSetCard(0x5) or c:IsCode(11819473,99189322,511000601)
end
function Card.IsDouble(c)
    return c:IsCode(94770493,511002019,511002559,511005035,511007029,511027048,1563)
end

local yesno = Duel.SelectYesNo
function Duel.SelectYesNo(tp, desc)
    if desc==aux.Stringid(4014, 6) then return true end
    return yesno(tp, desc)
end

function Card.GetMetatable(c,currentCode)
    local realcode,ocode,realalias=c:GetRealCode()
    if realcode>0 and ocode~=realcode then
        return c.__index
    else
        if currentCode then
            if _G["c" .. c:GetOriginalCode()] then return _G["c" .. c:GetOriginalCode()]
            else return _G["c" .. c:GetOriginalAlias()] end
        end
        return c.__index
    end
end

function Card.GetGodLevel(c)
    local ae = {c:IsHasEffect(805)}
    local godlv = -1
    for _, aec in ipairs(ae) do
        if aec:GetValue()>godlv then godlv=aec:GetValue() end
    end
    return godlv
end

function Card.HasLevel(c)
    local type = c:GetOriginalType()
	if not c:IsMonster() and not c:IsOriginalType(TYPE_MONSTER) then
        return false
    end
    local is_xyz = ( (bit.band(type,TYPE_XYZ)~=0 and bit.band(type,TYPE_LINK)==0) or (bit.band(type,TYPE_LINK)~=0 and (c:IsHasEffect(EFFECT_LINK_RANK) or c:IsHasEffect(EFFECT_LINK_RANK_S))) ) and bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))==0
    local is_link = ( (bit.band(type,TYPE_LINK)~=0 and bit.band(type,TYPE_XYZ)==0) or (bit.band(type,TYPE_XYZ)~=0 and (c:IsHasEffect(EFFECT_RANK_LINK) or c:IsHasEffect(EFFECT_RANK_LINK_S))) and not is_xyz ) and bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))==0
    local is_xyzlink = bit.band(type,TYPE_LINK)~=0 and bit.band(type,TYPE_XYZ)~=0 and bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))==0
    if ( (((is_xyz and not (c:IsHasEffect(EFFECT_RANK_LEVEL) or c:IsHasEffect(EFFECT_RANK_LEVEL_S)))
    or (is_link and not (c:IsHasEffect(EFFECT_LINK_LEVEL) or c:IsHasEffect(EFFECT_LINK_LEVEL_S)))
    or (is_xyzlink and not (c:IsHasEffect(EFFECT_RANK_LEVEL) or c:IsHasEffect(EFFECT_RANK_LEVEL_S) or c:IsHasEffect(EFFECT_LINK_LEVEL) or c:IsHasEffect(EFFECT_LINK_LEVEL_S))))
    and not (c:IsHasEffect(EFFECT_LEVEL_RANK_LINK) or c:IsHasEffect(EFFECT_LEVEL_RANK_LINK_S)))) then
        return false
    end
	return true
end
function Card.HasRank(c)
    local type = 0
    if c:IsMonster() then
        type = c:GetType()
	elseif c:IsOriginalType(TYPE_MONSTER) then
        type = c:GetOriginalType()
    else
        return false
    end
	local is_lv = bit.band(type,(TYPE_XYZ | TYPE_LINK))==0 or ( bit.band(type,TYPE_LINK)~=0 and bit.band(type,TYPE_XYZ)==0 and (c:IsHasEffect(EFFECT_LINK_LEVEL) or c:IsHasEffect(EFFECT_LINK_LEVEL_S)) )
	local is_link = (bit.band(type,TYPE_LINK)~=0 and bit.band(type,TYPE_XYZ)==0 and bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))==0) or ( bit.band(type,(TYPE_XYZ | TYPE_LINK))==0 and (c:IsHasEffect(EFFECT_LEVEL_LINK) or c:IsHasEffect(EFFECT_LEVEL_LINK_S)) and not is_lv )
	local is_lvlink = bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))~=0 and bit.band(type,TYPE_LINK)~=0 and bit.band(type,TYPE_XYZ)==0
	if ( (((is_lv and not (c:IsHasEffect(EFFECT_LEVEL_RANK) or c:IsHasEffect(EFFECT_LEVEL_RANK_S)))
	    or (is_link and not (c:IsHasEffect(EFFECT_LINK_RANK) or c:IsHasEffect(EFFECT_LINK_RANK_S)))
		or (is_lvlink and not (c:IsHasEffect(EFFECT_LEVEL_RANK) or c:IsHasEffect(EFFECT_LEVEL_RANK_S) or c:IsHasEffect(EFFECT_LINK_RANK) or c:IsHasEffect(EFFECT_LINK_RANK_S))))
		and not (c:IsHasEffect(EFFECT_LEVEL_RANK_LINK) or c:IsHasEffect(EFFECT_LEVEL_RANK_LINK_S)))) then
        return false
    end
    return true
end
function Card.HasLink(c)
    local type = c:GetOriginalType()
	if not c:IsMonster() and not c:IsOriginalType(TYPE_MONSTER) then
        return false
    end
    local is_lv = bit.band(type,(TYPE_XYZ | TYPE_LINK))==0 or ( bit.band(type,TYPE_XYZ)~=0 and bit.band(type,TYPE_LINK)==0 and (c:IsHasEffect(EFFECT_RANK_LEVEL) or c:IsHasEffect(EFFECT_RANK_LEVEL_S)) )
    local is_xyz = (bit.band(type,TYPE_XYZ)~=0 and bit.band(type,TYPE_LINK)==0 and bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))==0) or ( bit.band(type,(TYPE_XYZ | TYPE_LINK))==0 and (c:IsHasEffect(EFFECT_LEVEL_RANK) or c:IsHasEffect(EFFECT_LEVEL_RANK_S)) and not is_lv )
    local is_lvxyz = bit.band(type,(TYPE_FUSION | TYPE_SYNCHRO | TYPE_RITUAL))~=0 and bit.band(type,TYPE_XYZ)~=0 and bit.band(type,TYPE_LINK)==0
    if( (((is_lv and not (c:IsHasEffect(EFFECT_LEVEL_LINK) or c:IsHasEffect(EFFECT_LEVEL_LINK_S)))
        or (is_xyz and not c:IsHasEffect(EFFECT_RANK_LINK) or c:IsHasEffect(EFFECT_RANK_LINK_S)))
        or (is_lvxyz and not (c:IsHasEffect(EFFECT_LEVEL_LINK) or c:IsHasEffect(EFFECT_LEVEL_LINK_S) or c:IsHasEffect(EFFECT_RANK_LINK) or c:IsHasEffect(EFFECT_RANK_LINK_S))))
        and not (c:IsHasEffect(EFFECT_LEVEL_RANK_LINK) or c:IsHasEffect(EFFECT_LEVEL_RANK_LINK_S))) then
        return false
    end
    return true
end